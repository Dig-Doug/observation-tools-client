/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Client for observation-tools */
export declare class Client {
  beginExecution(name: string): ExecutionHandle;
  /**
   * Begin a new execution with a specific ID (for testing)
   *
   * This allows tests to create an execution with a known ID, enabling
   * navigation to the execution URL before the execution is uploaded.
   */
  beginExecutionWithId(id: string, name: string): ExecutionHandle;
}

/** Builder for Client */
export declare class ClientBuilder {
  /** Create a new client builder */
  constructor();
  /** Set the base URL for the server */
  setBaseUrl(url: string): void;
  /** Set the API key for authentication */
  setApiKey(apiKey: string): void;
  /** Build the client */
  build(): Client;
}

/** Handle to an execution that can be used to send observations */
export declare class ExecutionHandle {
  /** Get the execution ID as a string */
  get idString(): string;
  /** Get the URL to the execution page */
  get url(): string;
  /**
   * Create and send an observation
   *
   * # Arguments
   * * `name` - The name of the observation
   * * `payload_json` - The data to observe as a JSON string
   * * `labels` - Optional array of labels for categorization
   * * `source_file` - Optional source file path
   * * `source_line` - Optional source line number
   * * `metadata` - Optional metadata as an array of [key, value] pairs
   */
  observe(
    name: string,
    payloadJson: string,
    labels?: Array<string> | undefined | null,
    sourceFile?: string | undefined | null,
    sourceLine?: number | undefined | null,
    metadata?: Array<Array<string>> | undefined | null,
  ): string;
  /**
   * Create and send an observation with a specific ID (for testing)
   *
   * This allows tests to create an observation with a known ID, enabling
   * navigation to the observation URL before the observation is uploaded.
   *
   * # Arguments
   * * `id` - The observation ID to use
   * * `name` - The name of the observation
   * * `payload_json` - The data to observe as a JSON string
   * * `labels` - Optional array of labels for categorization
   * * `source_file` - Optional source file path
   * * `source_line` - Optional source line number
   * * `metadata` - Optional metadata as an array of [key, value] pairs
   */
  observeWithId(
    id: string,
    name: string,
    payloadJson: string,
    labels?: Array<string> | undefined | null,
    sourceFile?: string | undefined | null,
    sourceLine?: number | undefined | null,
    metadata?: Array<Array<string>> | undefined | null,
  ): string;
}

/**
 * Builder for creating observations (without payload set yet)
 *
 * Call `.payload()` or `.custom_payload()` to get an
 * `ObservationBuilderWithPayload` that can be built.
 */
export declare class ObservationBuilder {
  /** Create a new observation builder with the given name */
  constructor(name: string);
  /** Add a label to the observation */
  label(label: string): this;
  /** Add metadata to the observation */
  metadata(key: string, value: string): this;
  /** Set the source info for the observation */
  source(file: string, line: number): this;
  /** Set the payload as JSON data */
  jsonPayload(jsonString: string): ObservationBuilderWithPayload;
  /** Set the payload with custom data and MIME type */
  rawPayload(data: string, mimeType: string): ObservationBuilderWithPayload;
  /** Set the payload as markdown content */
  markdownPayload(content: string): ObservationBuilderWithPayload;
}

/**
 * Builder for creating observations (with payload set)
 *
 * This struct is returned by `ObservationBuilder::payload()` and
 * `ObservationBuilder::custom_payload()`. It has the `build()` methods
 * since a payload is required.
 */
export declare class ObservationBuilderWithPayload {
  /**
   * Build and send the observation
   *
   * Returns a SendObservation which allows you to wait for the upload to
   * complete or get the ObservationHandle immediately.
   *
   * If sending fails, returns a stub that will fail on `wait_for_upload()`.
   */
  send(execution: ExecutionHandle): SendObservation;
}

export declare class ObservationHandle {
  get url(): string;
}

export declare class SendObservation {
  handle(): ObservationHandle;
}

/**
 * Generate a new execution ID (for testing)
 *
 * This allows tests to generate an execution ID before creating the execution,
 * enabling navigation to the execution URL before the execution is uploaded.
 */
export declare function generateExecutionId(): string;

/**
 * Generate a new observation ID (for testing)
 *
 * This allows tests to generate an observation ID before creating the
 * observation, enabling navigation to the observation URL before the
 * observation is uploaded.
 */
export declare function generateObservationId(): string;
