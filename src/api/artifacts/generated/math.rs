// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/api/artifacts/math.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct Number {
    // message fields
    pub d: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Number {
    fn default() -> &'a Number {
        <Number as ::protobuf::Message>::default_instance()
    }
}

impl Number {
    pub fn new() -> Number {
        ::std::default::Default::default()
    }

    // double d = 1;


    pub fn get_d(&self) -> f64 {
        self.d
    }
    pub fn clear_d(&mut self) {
        self.d = 0.;
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: f64) {
        self.d = v;
    }
}

impl ::protobuf::Message for Number {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.d = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.d != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.d != 0. {
            os.write_double(1, self.d)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Number {
        Number::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "d",
                    |m: &Number| { &m.d },
                    |m: &mut Number| { &mut m.d },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Number>(
                    "Number",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Number {
        static mut instance: ::protobuf::lazy::Lazy<Number> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Number,
        };
        unsafe {
            instance.get(Number::new)
        }
    }
}

impl ::protobuf::Clear for Number {
    fn clear(&mut self) {
        self.d = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Number {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Number {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point2 {
    // message fields
    pub x: ::protobuf::SingularPtrField<Number>,
    pub y: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point2 {
    fn default() -> &'a Point2 {
        <Point2 as ::protobuf::Message>::default_instance()
    }
}

impl Point2 {
    pub fn new() -> Point2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number x = 1;


    pub fn get_x(&self) -> &Number {
        self.x.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Number) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Number {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Number {
        self.x.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number y = 2;


    pub fn get_y(&self) -> &Number {
        self.y.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Number) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Number {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Number {
        self.y.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Point2 {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point2 {
        Point2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "x",
                    |m: &Point2| { &m.x },
                    |m: &mut Point2| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "y",
                    |m: &Point2| { &m.y },
                    |m: &mut Point2| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Point2>(
                    "Point2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Point2 {
        static mut instance: ::protobuf::lazy::Lazy<Point2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Point2,
        };
        unsafe {
            instance.get(Point2::new)
        }
    }
}

impl ::protobuf::Clear for Point2 {
    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Segment2 {
    // message fields
    pub start: ::protobuf::SingularPtrField<Point2>,
    pub end: ::protobuf::SingularPtrField<Point2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Segment2 {
    fn default() -> &'a Segment2 {
        <Segment2 as ::protobuf::Message>::default_instance()
    }
}

impl Segment2 {
    pub fn new() -> Segment2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Point2 start = 1;


    pub fn get_start(&self) -> &Point2 {
        self.start.as_ref().unwrap_or_else(|| Point2::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: Point2) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut Point2 {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> Point2 {
        self.start.take().unwrap_or_else(|| Point2::new())
    }

    // .observation_tools.proto.Point2 end = 2;


    pub fn get_end(&self) -> &Point2 {
        self.end.as_ref().unwrap_or_else(|| Point2::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: Point2) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut Point2 {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> Point2 {
        self.end.take().unwrap_or_else(|| Point2::new())
    }
}

impl ::protobuf::Message for Segment2 {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Segment2 {
        Segment2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point2>>(
                    "start",
                    |m: &Segment2| { &m.start },
                    |m: &mut Segment2| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point2>>(
                    "end",
                    |m: &Segment2| { &m.end },
                    |m: &mut Segment2| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Segment2>(
                    "Segment2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Segment2 {
        static mut instance: ::protobuf::lazy::Lazy<Segment2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Segment2,
        };
        unsafe {
            instance.get(Segment2::new)
        }
    }
}

impl ::protobuf::Clear for Segment2 {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Segment2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Segment2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point3 {
    // message fields
    pub x: ::protobuf::SingularPtrField<Number>,
    pub y: ::protobuf::SingularPtrField<Number>,
    pub z: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point3 {
    fn default() -> &'a Point3 {
        <Point3 as ::protobuf::Message>::default_instance()
    }
}

impl Point3 {
    pub fn new() -> Point3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number x = 1;


    pub fn get_x(&self) -> &Number {
        self.x.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Number) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Number {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Number {
        self.x.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number y = 2;


    pub fn get_y(&self) -> &Number {
        self.y.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Number) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Number {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Number {
        self.y.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number z = 3;


    pub fn get_z(&self) -> &Number {
        self.z.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_z(&mut self) {
        self.z.clear();
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: Number) {
        self.z = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&mut self) -> &mut Number {
        if self.z.is_none() {
            self.z.set_default();
        }
        self.z.as_mut().unwrap()
    }

    // Take field
    pub fn take_z(&mut self) -> Number {
        self.z.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Point3 {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.z {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.z)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.z.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point3 {
        Point3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "x",
                    |m: &Point3| { &m.x },
                    |m: &mut Point3| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "y",
                    |m: &Point3| { &m.y },
                    |m: &mut Point3| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "z",
                    |m: &Point3| { &m.z },
                    |m: &mut Point3| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Point3>(
                    "Point3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Point3 {
        static mut instance: ::protobuf::lazy::Lazy<Point3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Point3,
        };
        unsafe {
            instance.get(Point3::new)
        }
    }
}

impl ::protobuf::Clear for Point3 {
    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vector2 {
    // message fields
    pub x: ::protobuf::SingularPtrField<Number>,
    pub y: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector2 {
    fn default() -> &'a Vector2 {
        <Vector2 as ::protobuf::Message>::default_instance()
    }
}

impl Vector2 {
    pub fn new() -> Vector2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number x = 1;


    pub fn get_x(&self) -> &Number {
        self.x.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Number) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Number {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Number {
        self.x.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number y = 2;


    pub fn get_y(&self) -> &Number {
        self.y.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Number) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Number {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Number {
        self.y.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Vector2 {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector2 {
        Vector2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "x",
                    |m: &Vector2| { &m.x },
                    |m: &mut Vector2| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "y",
                    |m: &Vector2| { &m.y },
                    |m: &mut Vector2| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vector2>(
                    "Vector2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vector2 {
        static mut instance: ::protobuf::lazy::Lazy<Vector2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vector2,
        };
        unsafe {
            instance.get(Vector2::new)
        }
    }
}

impl ::protobuf::Clear for Vector2 {
    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vector3 {
    // message fields
    pub x: ::protobuf::SingularPtrField<Number>,
    pub y: ::protobuf::SingularPtrField<Number>,
    pub z: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector3 {
    fn default() -> &'a Vector3 {
        <Vector3 as ::protobuf::Message>::default_instance()
    }
}

impl Vector3 {
    pub fn new() -> Vector3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number x = 1;


    pub fn get_x(&self) -> &Number {
        self.x.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Number) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Number {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Number {
        self.x.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number y = 2;


    pub fn get_y(&self) -> &Number {
        self.y.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Number) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Number {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Number {
        self.y.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number z = 3;


    pub fn get_z(&self) -> &Number {
        self.z.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_z(&mut self) {
        self.z.clear();
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: Number) {
        self.z = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&mut self) -> &mut Number {
        if self.z.is_none() {
            self.z.set_default();
        }
        self.z.as_mut().unwrap()
    }

    // Take field
    pub fn take_z(&mut self) -> Number {
        self.z.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Vector3 {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.z {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.z)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.z.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector3 {
        Vector3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "x",
                    |m: &Vector3| { &m.x },
                    |m: &mut Vector3| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "y",
                    |m: &Vector3| { &m.y },
                    |m: &mut Vector3| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "z",
                    |m: &Vector3| { &m.z },
                    |m: &mut Vector3| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vector3>(
                    "Vector3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vector3 {
        static mut instance: ::protobuf::lazy::Lazy<Vector3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vector3,
        };
        unsafe {
            instance.get(Vector3::new)
        }
    }
}

impl ::protobuf::Clear for Vector3 {
    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolygonEdge2 {
    // message fields
    pub vertex: ::protobuf::SingularPtrField<Point2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolygonEdge2 {
    fn default() -> &'a PolygonEdge2 {
        <PolygonEdge2 as ::protobuf::Message>::default_instance()
    }
}

impl PolygonEdge2 {
    pub fn new() -> PolygonEdge2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Point2 vertex = 1;


    pub fn get_vertex(&self) -> &Point2 {
        self.vertex.as_ref().unwrap_or_else(|| Point2::default_instance())
    }
    pub fn clear_vertex(&mut self) {
        self.vertex.clear();
    }

    pub fn has_vertex(&self) -> bool {
        self.vertex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertex(&mut self, v: Point2) {
        self.vertex = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertex(&mut self) -> &mut Point2 {
        if self.vertex.is_none() {
            self.vertex.set_default();
        }
        self.vertex.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertex(&mut self) -> Point2 {
        self.vertex.take().unwrap_or_else(|| Point2::new())
    }
}

impl ::protobuf::Message for PolygonEdge2 {
    fn is_initialized(&self) -> bool {
        for v in &self.vertex {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vertex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vertex.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolygonEdge2 {
        PolygonEdge2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point2>>(
                    "vertex",
                    |m: &PolygonEdge2| { &m.vertex },
                    |m: &mut PolygonEdge2| { &mut m.vertex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PolygonEdge2>(
                    "PolygonEdge2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolygonEdge2 {
        static mut instance: ::protobuf::lazy::Lazy<PolygonEdge2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolygonEdge2,
        };
        unsafe {
            instance.get(PolygonEdge2::new)
        }
    }
}

impl ::protobuf::Clear for PolygonEdge2 {
    fn clear(&mut self) {
        self.vertex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolygonEdge2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolygonEdge2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Polygon2 {
    // message fields
    pub edges: ::protobuf::RepeatedField<PolygonEdge2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Polygon2 {
    fn default() -> &'a Polygon2 {
        <Polygon2 as ::protobuf::Message>::default_instance()
    }
}

impl Polygon2 {
    pub fn new() -> Polygon2 {
        ::std::default::Default::default()
    }

    // repeated .observation_tools.proto.PolygonEdge2 edges = 1;


    pub fn get_edges(&self) -> &[PolygonEdge2] {
        &self.edges
    }
    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<PolygonEdge2>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<PolygonEdge2> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<PolygonEdge2> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Polygon2 {
    fn is_initialized(&self) -> bool {
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.edges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Polygon2 {
        Polygon2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolygonEdge2>>(
                    "edges",
                    |m: &Polygon2| { &m.edges },
                    |m: &mut Polygon2| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Polygon2>(
                    "Polygon2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Polygon2 {
        static mut instance: ::protobuf::lazy::Lazy<Polygon2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Polygon2,
        };
        unsafe {
            instance.get(Polygon2::new)
        }
    }
}

impl ::protobuf::Clear for Polygon2 {
    fn clear(&mut self) {
        self.edges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Polygon2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Polygon2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Graph {
    // message fields
    pub nodes: ::std::collections::HashMap<::std::string::String, GraphNode>,
    pub edges: ::std::collections::HashMap<::std::string::String, GraphEdge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Graph {
    fn default() -> &'a Graph {
        <Graph as ::protobuf::Message>::default_instance()
    }
}

impl Graph {
    pub fn new() -> Graph {
        ::std::default::Default::default()
    }

    // repeated .observation_tools.proto.Graph.NodesEntry nodes = 1;


    pub fn get_nodes(&self) -> &::std::collections::HashMap<::std::string::String, GraphNode> {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::std::collections::HashMap<::std::string::String, GraphNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, GraphNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::std::collections::HashMap<::std::string::String, GraphNode> {
        ::std::mem::replace(&mut self.nodes, ::std::collections::HashMap::new())
    }

    // repeated .observation_tools.proto.Graph.EdgesEntry edges = 2;


    pub fn get_edges(&self) -> &::std::collections::HashMap<::std::string::String, GraphEdge> {
        &self.edges
    }
    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::std::collections::HashMap<::std::string::String, GraphEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, GraphEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::std::collections::HashMap<::std::string::String, GraphEdge> {
        ::std::mem::replace(&mut self.edges, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Graph {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphNode>>(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphEdge>>(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphNode>>(1, &self.nodes);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphEdge>>(2, &self.edges);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphNode>>(1, &self.nodes, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphEdge>>(2, &self.edges, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Graph {
        Graph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphNode>>(
                    "nodes",
                    |m: &Graph| { &m.nodes },
                    |m: &mut Graph| { &mut m.nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GraphEdge>>(
                    "edges",
                    |m: &Graph| { &m.edges },
                    |m: &mut Graph| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Graph>(
                    "Graph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Graph {
        static mut instance: ::protobuf::lazy::Lazy<Graph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Graph,
        };
        unsafe {
            instance.get(Graph::new)
        }
    }
}

impl ::protobuf::Clear for Graph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.edges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Graph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Graph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphNode {
    // message fields
    pub position: ::protobuf::SingularPtrField<Point3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphNode {
    fn default() -> &'a GraphNode {
        <GraphNode as ::protobuf::Message>::default_instance()
    }
}

impl GraphNode {
    pub fn new() -> GraphNode {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Point3 position = 1;


    pub fn get_position(&self) -> &Point3 {
        self.position.as_ref().unwrap_or_else(|| Point3::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Point3) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Point3 {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Point3 {
        self.position.take().unwrap_or_else(|| Point3::new())
    }
}

impl ::protobuf::Message for GraphNode {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphNode {
        GraphNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point3>>(
                    "position",
                    |m: &GraphNode| { &m.position },
                    |m: &mut GraphNode| { &mut m.position },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphNode>(
                    "GraphNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphNode {
        static mut instance: ::protobuf::lazy::Lazy<GraphNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphNode,
        };
        unsafe {
            instance.get(GraphNode::new)
        }
    }
}

impl ::protobuf::Clear for GraphNode {
    fn clear(&mut self) {
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphEdge {
    // message fields
    pub start_node_id: ::std::string::String,
    pub end_node_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphEdge {
    fn default() -> &'a GraphEdge {
        <GraphEdge as ::protobuf::Message>::default_instance()
    }
}

impl GraphEdge {
    pub fn new() -> GraphEdge {
        ::std::default::Default::default()
    }

    // string start_node_id = 1;


    pub fn get_start_node_id(&self) -> &str {
        &self.start_node_id
    }
    pub fn clear_start_node_id(&mut self) {
        self.start_node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_node_id(&mut self, v: ::std::string::String) {
        self.start_node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.start_node_id
    }

    // Take field
    pub fn take_start_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start_node_id, ::std::string::String::new())
    }

    // string end_node_id = 2;


    pub fn get_end_node_id(&self) -> &str {
        &self.end_node_id
    }
    pub fn clear_end_node_id(&mut self) {
        self.end_node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_node_id(&mut self, v: ::std::string::String) {
        self.end_node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.end_node_id
    }

    // Take field
    pub fn take_end_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.end_node_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GraphEdge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.start_node_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.end_node_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start_node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.start_node_id);
        }
        if !self.end_node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.end_node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.start_node_id.is_empty() {
            os.write_string(1, &self.start_node_id)?;
        }
        if !self.end_node_id.is_empty() {
            os.write_string(2, &self.end_node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphEdge {
        GraphEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "start_node_id",
                    |m: &GraphEdge| { &m.start_node_id },
                    |m: &mut GraphEdge| { &mut m.start_node_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "end_node_id",
                    |m: &GraphEdge| { &m.end_node_id },
                    |m: &mut GraphEdge| { &mut m.end_node_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphEdge>(
                    "GraphEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphEdge {
        static mut instance: ::protobuf::lazy::Lazy<GraphEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphEdge,
        };
        unsafe {
            instance.get(GraphEdge::new)
        }
    }
}

impl ::protobuf::Clear for GraphEdge {
    fn clear(&mut self) {
        self.start_node_id.clear();
        self.end_node_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Matrix3x3 {
    // message fields
    pub m0_0: ::protobuf::SingularPtrField<Number>,
    pub m0_1: ::protobuf::SingularPtrField<Number>,
    pub m0_2: ::protobuf::SingularPtrField<Number>,
    pub m1_0: ::protobuf::SingularPtrField<Number>,
    pub m1_1: ::protobuf::SingularPtrField<Number>,
    pub m1_2: ::protobuf::SingularPtrField<Number>,
    pub m2_0: ::protobuf::SingularPtrField<Number>,
    pub m2_1: ::protobuf::SingularPtrField<Number>,
    pub m2_2: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Matrix3x3 {
    fn default() -> &'a Matrix3x3 {
        <Matrix3x3 as ::protobuf::Message>::default_instance()
    }
}

impl Matrix3x3 {
    pub fn new() -> Matrix3x3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number m0_0 = 1;


    pub fn get_m0_0(&self) -> &Number {
        self.m0_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_0(&mut self) {
        self.m0_0.clear();
    }

    pub fn has_m0_0(&self) -> bool {
        self.m0_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_0(&mut self, v: Number) {
        self.m0_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_0(&mut self) -> &mut Number {
        if self.m0_0.is_none() {
            self.m0_0.set_default();
        }
        self.m0_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_0(&mut self) -> Number {
        self.m0_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m0_1 = 2;


    pub fn get_m0_1(&self) -> &Number {
        self.m0_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_1(&mut self) {
        self.m0_1.clear();
    }

    pub fn has_m0_1(&self) -> bool {
        self.m0_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_1(&mut self, v: Number) {
        self.m0_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_1(&mut self) -> &mut Number {
        if self.m0_1.is_none() {
            self.m0_1.set_default();
        }
        self.m0_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_1(&mut self) -> Number {
        self.m0_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m0_2 = 3;


    pub fn get_m0_2(&self) -> &Number {
        self.m0_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_2(&mut self) {
        self.m0_2.clear();
    }

    pub fn has_m0_2(&self) -> bool {
        self.m0_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_2(&mut self, v: Number) {
        self.m0_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_2(&mut self) -> &mut Number {
        if self.m0_2.is_none() {
            self.m0_2.set_default();
        }
        self.m0_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_2(&mut self) -> Number {
        self.m0_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_0 = 4;


    pub fn get_m1_0(&self) -> &Number {
        self.m1_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_0(&mut self) {
        self.m1_0.clear();
    }

    pub fn has_m1_0(&self) -> bool {
        self.m1_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_0(&mut self, v: Number) {
        self.m1_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_0(&mut self) -> &mut Number {
        if self.m1_0.is_none() {
            self.m1_0.set_default();
        }
        self.m1_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_0(&mut self) -> Number {
        self.m1_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_1 = 5;


    pub fn get_m1_1(&self) -> &Number {
        self.m1_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_1(&mut self) {
        self.m1_1.clear();
    }

    pub fn has_m1_1(&self) -> bool {
        self.m1_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_1(&mut self, v: Number) {
        self.m1_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_1(&mut self) -> &mut Number {
        if self.m1_1.is_none() {
            self.m1_1.set_default();
        }
        self.m1_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_1(&mut self) -> Number {
        self.m1_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_2 = 6;


    pub fn get_m1_2(&self) -> &Number {
        self.m1_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_2(&mut self) {
        self.m1_2.clear();
    }

    pub fn has_m1_2(&self) -> bool {
        self.m1_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_2(&mut self, v: Number) {
        self.m1_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_2(&mut self) -> &mut Number {
        if self.m1_2.is_none() {
            self.m1_2.set_default();
        }
        self.m1_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_2(&mut self) -> Number {
        self.m1_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_0 = 7;


    pub fn get_m2_0(&self) -> &Number {
        self.m2_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_0(&mut self) {
        self.m2_0.clear();
    }

    pub fn has_m2_0(&self) -> bool {
        self.m2_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_0(&mut self, v: Number) {
        self.m2_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_0(&mut self) -> &mut Number {
        if self.m2_0.is_none() {
            self.m2_0.set_default();
        }
        self.m2_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_0(&mut self) -> Number {
        self.m2_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_1 = 8;


    pub fn get_m2_1(&self) -> &Number {
        self.m2_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_1(&mut self) {
        self.m2_1.clear();
    }

    pub fn has_m2_1(&self) -> bool {
        self.m2_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_1(&mut self, v: Number) {
        self.m2_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_1(&mut self) -> &mut Number {
        if self.m2_1.is_none() {
            self.m2_1.set_default();
        }
        self.m2_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_1(&mut self) -> Number {
        self.m2_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_2 = 9;


    pub fn get_m2_2(&self) -> &Number {
        self.m2_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_2(&mut self) {
        self.m2_2.clear();
    }

    pub fn has_m2_2(&self) -> bool {
        self.m2_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_2(&mut self, v: Number) {
        self.m2_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_2(&mut self) -> &mut Number {
        if self.m2_2.is_none() {
            self.m2_2.set_default();
        }
        self.m2_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_2(&mut self) -> Number {
        self.m2_2.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Matrix3x3 {
    fn is_initialized(&self) -> bool {
        for v in &self.m0_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m0_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m0_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_0)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_2)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_0)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_1)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.m0_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m0_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m0_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.m0_0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m0_1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m0_2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_0.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_1.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_2.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_0.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_1.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_2.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Matrix3x3 {
        Matrix3x3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_0",
                    |m: &Matrix3x3| { &m.m0_0 },
                    |m: &mut Matrix3x3| { &mut m.m0_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_1",
                    |m: &Matrix3x3| { &m.m0_1 },
                    |m: &mut Matrix3x3| { &mut m.m0_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_2",
                    |m: &Matrix3x3| { &m.m0_2 },
                    |m: &mut Matrix3x3| { &mut m.m0_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_0",
                    |m: &Matrix3x3| { &m.m1_0 },
                    |m: &mut Matrix3x3| { &mut m.m1_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_1",
                    |m: &Matrix3x3| { &m.m1_1 },
                    |m: &mut Matrix3x3| { &mut m.m1_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_2",
                    |m: &Matrix3x3| { &m.m1_2 },
                    |m: &mut Matrix3x3| { &mut m.m1_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_0",
                    |m: &Matrix3x3| { &m.m2_0 },
                    |m: &mut Matrix3x3| { &mut m.m2_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_1",
                    |m: &Matrix3x3| { &m.m2_1 },
                    |m: &mut Matrix3x3| { &mut m.m2_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_2",
                    |m: &Matrix3x3| { &m.m2_2 },
                    |m: &mut Matrix3x3| { &mut m.m2_2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Matrix3x3>(
                    "Matrix3x3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Matrix3x3 {
        static mut instance: ::protobuf::lazy::Lazy<Matrix3x3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Matrix3x3,
        };
        unsafe {
            instance.get(Matrix3x3::new)
        }
    }
}

impl ::protobuf::Clear for Matrix3x3 {
    fn clear(&mut self) {
        self.m0_0.clear();
        self.m0_1.clear();
        self.m0_2.clear();
        self.m1_0.clear();
        self.m1_1.clear();
        self.m1_2.clear();
        self.m2_0.clear();
        self.m2_1.clear();
        self.m2_2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Matrix3x3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Matrix3x3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Matrix4x4 {
    // message fields
    pub m0_0: ::protobuf::SingularPtrField<Number>,
    pub m0_1: ::protobuf::SingularPtrField<Number>,
    pub m0_2: ::protobuf::SingularPtrField<Number>,
    pub m0_3: ::protobuf::SingularPtrField<Number>,
    pub m1_0: ::protobuf::SingularPtrField<Number>,
    pub m1_1: ::protobuf::SingularPtrField<Number>,
    pub m1_2: ::protobuf::SingularPtrField<Number>,
    pub m1_3: ::protobuf::SingularPtrField<Number>,
    pub m2_0: ::protobuf::SingularPtrField<Number>,
    pub m2_1: ::protobuf::SingularPtrField<Number>,
    pub m2_2: ::protobuf::SingularPtrField<Number>,
    pub m2_3: ::protobuf::SingularPtrField<Number>,
    pub m3_0: ::protobuf::SingularPtrField<Number>,
    pub m3_1: ::protobuf::SingularPtrField<Number>,
    pub m3_2: ::protobuf::SingularPtrField<Number>,
    pub m3_3: ::protobuf::SingularPtrField<Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Matrix4x4 {
    fn default() -> &'a Matrix4x4 {
        <Matrix4x4 as ::protobuf::Message>::default_instance()
    }
}

impl Matrix4x4 {
    pub fn new() -> Matrix4x4 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number m0_0 = 1;


    pub fn get_m0_0(&self) -> &Number {
        self.m0_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_0(&mut self) {
        self.m0_0.clear();
    }

    pub fn has_m0_0(&self) -> bool {
        self.m0_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_0(&mut self, v: Number) {
        self.m0_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_0(&mut self) -> &mut Number {
        if self.m0_0.is_none() {
            self.m0_0.set_default();
        }
        self.m0_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_0(&mut self) -> Number {
        self.m0_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m0_1 = 2;


    pub fn get_m0_1(&self) -> &Number {
        self.m0_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_1(&mut self) {
        self.m0_1.clear();
    }

    pub fn has_m0_1(&self) -> bool {
        self.m0_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_1(&mut self, v: Number) {
        self.m0_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_1(&mut self) -> &mut Number {
        if self.m0_1.is_none() {
            self.m0_1.set_default();
        }
        self.m0_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_1(&mut self) -> Number {
        self.m0_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m0_2 = 3;


    pub fn get_m0_2(&self) -> &Number {
        self.m0_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_2(&mut self) {
        self.m0_2.clear();
    }

    pub fn has_m0_2(&self) -> bool {
        self.m0_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_2(&mut self, v: Number) {
        self.m0_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_2(&mut self) -> &mut Number {
        if self.m0_2.is_none() {
            self.m0_2.set_default();
        }
        self.m0_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_2(&mut self) -> Number {
        self.m0_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m0_3 = 4;


    pub fn get_m0_3(&self) -> &Number {
        self.m0_3.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m0_3(&mut self) {
        self.m0_3.clear();
    }

    pub fn has_m0_3(&self) -> bool {
        self.m0_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m0_3(&mut self, v: Number) {
        self.m0_3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m0_3(&mut self) -> &mut Number {
        if self.m0_3.is_none() {
            self.m0_3.set_default();
        }
        self.m0_3.as_mut().unwrap()
    }

    // Take field
    pub fn take_m0_3(&mut self) -> Number {
        self.m0_3.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_0 = 5;


    pub fn get_m1_0(&self) -> &Number {
        self.m1_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_0(&mut self) {
        self.m1_0.clear();
    }

    pub fn has_m1_0(&self) -> bool {
        self.m1_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_0(&mut self, v: Number) {
        self.m1_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_0(&mut self) -> &mut Number {
        if self.m1_0.is_none() {
            self.m1_0.set_default();
        }
        self.m1_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_0(&mut self) -> Number {
        self.m1_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_1 = 6;


    pub fn get_m1_1(&self) -> &Number {
        self.m1_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_1(&mut self) {
        self.m1_1.clear();
    }

    pub fn has_m1_1(&self) -> bool {
        self.m1_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_1(&mut self, v: Number) {
        self.m1_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_1(&mut self) -> &mut Number {
        if self.m1_1.is_none() {
            self.m1_1.set_default();
        }
        self.m1_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_1(&mut self) -> Number {
        self.m1_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_2 = 7;


    pub fn get_m1_2(&self) -> &Number {
        self.m1_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_2(&mut self) {
        self.m1_2.clear();
    }

    pub fn has_m1_2(&self) -> bool {
        self.m1_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_2(&mut self, v: Number) {
        self.m1_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_2(&mut self) -> &mut Number {
        if self.m1_2.is_none() {
            self.m1_2.set_default();
        }
        self.m1_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_2(&mut self) -> Number {
        self.m1_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m1_3 = 8;


    pub fn get_m1_3(&self) -> &Number {
        self.m1_3.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m1_3(&mut self) {
        self.m1_3.clear();
    }

    pub fn has_m1_3(&self) -> bool {
        self.m1_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m1_3(&mut self, v: Number) {
        self.m1_3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1_3(&mut self) -> &mut Number {
        if self.m1_3.is_none() {
            self.m1_3.set_default();
        }
        self.m1_3.as_mut().unwrap()
    }

    // Take field
    pub fn take_m1_3(&mut self) -> Number {
        self.m1_3.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_0 = 9;


    pub fn get_m2_0(&self) -> &Number {
        self.m2_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_0(&mut self) {
        self.m2_0.clear();
    }

    pub fn has_m2_0(&self) -> bool {
        self.m2_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_0(&mut self, v: Number) {
        self.m2_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_0(&mut self) -> &mut Number {
        if self.m2_0.is_none() {
            self.m2_0.set_default();
        }
        self.m2_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_0(&mut self) -> Number {
        self.m2_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_1 = 10;


    pub fn get_m2_1(&self) -> &Number {
        self.m2_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_1(&mut self) {
        self.m2_1.clear();
    }

    pub fn has_m2_1(&self) -> bool {
        self.m2_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_1(&mut self, v: Number) {
        self.m2_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_1(&mut self) -> &mut Number {
        if self.m2_1.is_none() {
            self.m2_1.set_default();
        }
        self.m2_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_1(&mut self) -> Number {
        self.m2_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_2 = 11;


    pub fn get_m2_2(&self) -> &Number {
        self.m2_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_2(&mut self) {
        self.m2_2.clear();
    }

    pub fn has_m2_2(&self) -> bool {
        self.m2_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_2(&mut self, v: Number) {
        self.m2_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_2(&mut self) -> &mut Number {
        if self.m2_2.is_none() {
            self.m2_2.set_default();
        }
        self.m2_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_2(&mut self) -> Number {
        self.m2_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m2_3 = 12;


    pub fn get_m2_3(&self) -> &Number {
        self.m2_3.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m2_3(&mut self) {
        self.m2_3.clear();
    }

    pub fn has_m2_3(&self) -> bool {
        self.m2_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m2_3(&mut self, v: Number) {
        self.m2_3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2_3(&mut self) -> &mut Number {
        if self.m2_3.is_none() {
            self.m2_3.set_default();
        }
        self.m2_3.as_mut().unwrap()
    }

    // Take field
    pub fn take_m2_3(&mut self) -> Number {
        self.m2_3.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m3_0 = 13;


    pub fn get_m3_0(&self) -> &Number {
        self.m3_0.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m3_0(&mut self) {
        self.m3_0.clear();
    }

    pub fn has_m3_0(&self) -> bool {
        self.m3_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m3_0(&mut self, v: Number) {
        self.m3_0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m3_0(&mut self) -> &mut Number {
        if self.m3_0.is_none() {
            self.m3_0.set_default();
        }
        self.m3_0.as_mut().unwrap()
    }

    // Take field
    pub fn take_m3_0(&mut self) -> Number {
        self.m3_0.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m3_1 = 14;


    pub fn get_m3_1(&self) -> &Number {
        self.m3_1.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m3_1(&mut self) {
        self.m3_1.clear();
    }

    pub fn has_m3_1(&self) -> bool {
        self.m3_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m3_1(&mut self, v: Number) {
        self.m3_1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m3_1(&mut self) -> &mut Number {
        if self.m3_1.is_none() {
            self.m3_1.set_default();
        }
        self.m3_1.as_mut().unwrap()
    }

    // Take field
    pub fn take_m3_1(&mut self) -> Number {
        self.m3_1.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m3_2 = 15;


    pub fn get_m3_2(&self) -> &Number {
        self.m3_2.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m3_2(&mut self) {
        self.m3_2.clear();
    }

    pub fn has_m3_2(&self) -> bool {
        self.m3_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m3_2(&mut self, v: Number) {
        self.m3_2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m3_2(&mut self) -> &mut Number {
        if self.m3_2.is_none() {
            self.m3_2.set_default();
        }
        self.m3_2.as_mut().unwrap()
    }

    // Take field
    pub fn take_m3_2(&mut self) -> Number {
        self.m3_2.take().unwrap_or_else(|| Number::new())
    }

    // .observation_tools.proto.Number m3_3 = 16;


    pub fn get_m3_3(&self) -> &Number {
        self.m3_3.as_ref().unwrap_or_else(|| Number::default_instance())
    }
    pub fn clear_m3_3(&mut self) {
        self.m3_3.clear();
    }

    pub fn has_m3_3(&self) -> bool {
        self.m3_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m3_3(&mut self, v: Number) {
        self.m3_3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m3_3(&mut self) -> &mut Number {
        if self.m3_3.is_none() {
            self.m3_3.set_default();
        }
        self.m3_3.as_mut().unwrap()
    }

    // Take field
    pub fn take_m3_3(&mut self) -> Number {
        self.m3_3.take().unwrap_or_else(|| Number::new())
    }
}

impl ::protobuf::Message for Matrix4x4 {
    fn is_initialized(&self) -> bool {
        for v in &self.m0_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m0_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m0_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m0_3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m1_3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m2_3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m3_0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m3_1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m3_2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.m3_3 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m0_3)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_0)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_1)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_2)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m1_3)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_0)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_1)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_2)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m2_3)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m3_0)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m3_1)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m3_2)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.m3_3)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.m0_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m0_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m0_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m0_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m1_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m2_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m3_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m3_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m3_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.m3_3.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.m0_0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m0_1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m0_2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m0_3.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_0.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_1.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m1_3.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_0.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_1.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_2.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m2_3.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m3_0.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m3_1.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m3_2.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.m3_3.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Matrix4x4 {
        Matrix4x4::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_0",
                    |m: &Matrix4x4| { &m.m0_0 },
                    |m: &mut Matrix4x4| { &mut m.m0_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_1",
                    |m: &Matrix4x4| { &m.m0_1 },
                    |m: &mut Matrix4x4| { &mut m.m0_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_2",
                    |m: &Matrix4x4| { &m.m0_2 },
                    |m: &mut Matrix4x4| { &mut m.m0_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m0_3",
                    |m: &Matrix4x4| { &m.m0_3 },
                    |m: &mut Matrix4x4| { &mut m.m0_3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_0",
                    |m: &Matrix4x4| { &m.m1_0 },
                    |m: &mut Matrix4x4| { &mut m.m1_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_1",
                    |m: &Matrix4x4| { &m.m1_1 },
                    |m: &mut Matrix4x4| { &mut m.m1_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_2",
                    |m: &Matrix4x4| { &m.m1_2 },
                    |m: &mut Matrix4x4| { &mut m.m1_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m1_3",
                    |m: &Matrix4x4| { &m.m1_3 },
                    |m: &mut Matrix4x4| { &mut m.m1_3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_0",
                    |m: &Matrix4x4| { &m.m2_0 },
                    |m: &mut Matrix4x4| { &mut m.m2_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_1",
                    |m: &Matrix4x4| { &m.m2_1 },
                    |m: &mut Matrix4x4| { &mut m.m2_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_2",
                    |m: &Matrix4x4| { &m.m2_2 },
                    |m: &mut Matrix4x4| { &mut m.m2_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m2_3",
                    |m: &Matrix4x4| { &m.m2_3 },
                    |m: &mut Matrix4x4| { &mut m.m2_3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m3_0",
                    |m: &Matrix4x4| { &m.m3_0 },
                    |m: &mut Matrix4x4| { &mut m.m3_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m3_1",
                    |m: &Matrix4x4| { &m.m3_1 },
                    |m: &mut Matrix4x4| { &mut m.m3_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m3_2",
                    |m: &Matrix4x4| { &m.m3_2 },
                    |m: &mut Matrix4x4| { &mut m.m3_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Number>>(
                    "m3_3",
                    |m: &Matrix4x4| { &m.m3_3 },
                    |m: &mut Matrix4x4| { &mut m.m3_3 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Matrix4x4>(
                    "Matrix4x4",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Matrix4x4 {
        static mut instance: ::protobuf::lazy::Lazy<Matrix4x4> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Matrix4x4,
        };
        unsafe {
            instance.get(Matrix4x4::new)
        }
    }
}

impl ::protobuf::Clear for Matrix4x4 {
    fn clear(&mut self) {
        self.m0_0.clear();
        self.m0_1.clear();
        self.m0_2.clear();
        self.m0_3.clear();
        self.m1_0.clear();
        self.m1_1.clear();
        self.m1_2.clear();
        self.m1_3.clear();
        self.m2_0.clear();
        self.m2_1.clear();
        self.m2_2.clear();
        self.m2_3.clear();
        self.m3_0.clear();
        self.m3_1.clear();
        self.m3_2.clear();
        self.m3_3.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Matrix4x4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Matrix4x4 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transform2 {
    // message oneof groups
    pub data: ::std::option::Option<Transform2_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transform2 {
    fn default() -> &'a Transform2 {
        <Transform2 as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transform2_oneof_data {
    trs(TRS2),
    identity(bool),
}

impl Transform2 {
    pub fn new() -> Transform2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.TRS2 trs = 1;


    pub fn get_trs(&self) -> &TRS2 {
        match self.data {
            ::std::option::Option::Some(Transform2_oneof_data::trs(ref v)) => v,
            _ => TRS2::default_instance(),
        }
    }
    pub fn clear_trs(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_trs(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform2_oneof_data::trs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trs(&mut self, v: TRS2) {
        self.data = ::std::option::Option::Some(Transform2_oneof_data::trs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trs(&mut self) -> &mut TRS2 {
        if let ::std::option::Option::Some(Transform2_oneof_data::trs(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Transform2_oneof_data::trs(TRS2::new()));
        }
        match self.data {
            ::std::option::Option::Some(Transform2_oneof_data::trs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trs(&mut self) -> TRS2 {
        if self.has_trs() {
            match self.data.take() {
                ::std::option::Option::Some(Transform2_oneof_data::trs(v)) => v,
                _ => panic!(),
            }
        } else {
            TRS2::new()
        }
    }

    // bool identity = 2;


    pub fn get_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform2_oneof_data::identity(v)) => v,
            _ => false,
        }
    }
    pub fn clear_identity(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform2_oneof_data::identity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(Transform2_oneof_data::identity(v))
    }
}

impl ::protobuf::Message for Transform2 {
    fn is_initialized(&self) -> bool {
        if let Some(Transform2_oneof_data::trs(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Transform2_oneof_data::trs(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Transform2_oneof_data::identity(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Transform2_oneof_data::trs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transform2_oneof_data::identity(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Transform2_oneof_data::trs(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transform2_oneof_data::identity(v) => {
                    os.write_bool(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transform2 {
        Transform2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TRS2>(
                    "trs",
                    Transform2::has_trs,
                    Transform2::get_trs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "identity",
                    Transform2::has_identity,
                    Transform2::get_identity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transform2>(
                    "Transform2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transform2 {
        static mut instance: ::protobuf::lazy::Lazy<Transform2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transform2,
        };
        unsafe {
            instance.get(Transform2::new)
        }
    }
}

impl ::protobuf::Clear for Transform2 {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transform2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transform3 {
    // message oneof groups
    pub data: ::std::option::Option<Transform3_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transform3 {
    fn default() -> &'a Transform3 {
        <Transform3 as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transform3_oneof_data {
    trs(TRS3),
    matrix(Matrix4x4),
    identity(bool),
}

impl Transform3 {
    pub fn new() -> Transform3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.TRS3 trs = 1;


    pub fn get_trs(&self) -> &TRS3 {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::trs(ref v)) => v,
            _ => TRS3::default_instance(),
        }
    }
    pub fn clear_trs(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_trs(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::trs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trs(&mut self, v: TRS3) {
        self.data = ::std::option::Option::Some(Transform3_oneof_data::trs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trs(&mut self) -> &mut TRS3 {
        if let ::std::option::Option::Some(Transform3_oneof_data::trs(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Transform3_oneof_data::trs(TRS3::new()));
        }
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::trs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trs(&mut self) -> TRS3 {
        if self.has_trs() {
            match self.data.take() {
                ::std::option::Option::Some(Transform3_oneof_data::trs(v)) => v,
                _ => panic!(),
            }
        } else {
            TRS3::new()
        }
    }

    // .observation_tools.proto.Matrix4x4 matrix = 2;


    pub fn get_matrix(&self) -> &Matrix4x4 {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::matrix(ref v)) => v,
            _ => Matrix4x4::default_instance(),
        }
    }
    pub fn clear_matrix(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_matrix(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::matrix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matrix(&mut self, v: Matrix4x4) {
        self.data = ::std::option::Option::Some(Transform3_oneof_data::matrix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matrix(&mut self) -> &mut Matrix4x4 {
        if let ::std::option::Option::Some(Transform3_oneof_data::matrix(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Transform3_oneof_data::matrix(Matrix4x4::new()));
        }
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::matrix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matrix(&mut self) -> Matrix4x4 {
        if self.has_matrix() {
            match self.data.take() {
                ::std::option::Option::Some(Transform3_oneof_data::matrix(v)) => v,
                _ => panic!(),
            }
        } else {
            Matrix4x4::new()
        }
    }

    // bool identity = 3;


    pub fn get_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::identity(v)) => v,
            _ => false,
        }
    }
    pub fn clear_identity(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Transform3_oneof_data::identity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(Transform3_oneof_data::identity(v))
    }
}

impl ::protobuf::Message for Transform3 {
    fn is_initialized(&self) -> bool {
        if let Some(Transform3_oneof_data::trs(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transform3_oneof_data::matrix(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Transform3_oneof_data::trs(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Transform3_oneof_data::matrix(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Transform3_oneof_data::identity(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Transform3_oneof_data::trs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transform3_oneof_data::matrix(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transform3_oneof_data::identity(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Transform3_oneof_data::trs(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transform3_oneof_data::matrix(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transform3_oneof_data::identity(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transform3 {
        Transform3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TRS3>(
                    "trs",
                    Transform3::has_trs,
                    Transform3::get_trs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Matrix4x4>(
                    "matrix",
                    Transform3::has_matrix,
                    Transform3::get_matrix,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "identity",
                    Transform3::has_identity,
                    Transform3::get_identity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transform3>(
                    "Transform3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transform3 {
        static mut instance: ::protobuf::lazy::Lazy<Transform3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transform3,
        };
        unsafe {
            instance.get(Transform3::new)
        }
    }
}

impl ::protobuf::Clear for Transform3 {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transform3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TRS2 {
    // message fields
    pub translation: ::protobuf::SingularPtrField<Vector2>,
    pub scale: ::protobuf::SingularPtrField<Vector2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TRS2 {
    fn default() -> &'a TRS2 {
        <TRS2 as ::protobuf::Message>::default_instance()
    }
}

impl TRS2 {
    pub fn new() -> TRS2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Vector2 translation = 1;


    pub fn get_translation(&self) -> &Vector2 {
        self.translation.as_ref().unwrap_or_else(|| Vector2::default_instance())
    }
    pub fn clear_translation(&mut self) {
        self.translation.clear();
    }

    pub fn has_translation(&self) -> bool {
        self.translation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translation(&mut self, v: Vector2) {
        self.translation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translation(&mut self) -> &mut Vector2 {
        if self.translation.is_none() {
            self.translation.set_default();
        }
        self.translation.as_mut().unwrap()
    }

    // Take field
    pub fn take_translation(&mut self) -> Vector2 {
        self.translation.take().unwrap_or_else(|| Vector2::new())
    }

    // .observation_tools.proto.Vector2 scale = 3;


    pub fn get_scale(&self) -> &Vector2 {
        self.scale.as_ref().unwrap_or_else(|| Vector2::default_instance())
    }
    pub fn clear_scale(&mut self) {
        self.scale.clear();
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: Vector2) {
        self.scale = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale(&mut self) -> &mut Vector2 {
        if self.scale.is_none() {
            self.scale.set_default();
        }
        self.scale.as_mut().unwrap()
    }

    // Take field
    pub fn take_scale(&mut self) -> Vector2 {
        self.scale.take().unwrap_or_else(|| Vector2::new())
    }
}

impl ::protobuf::Message for TRS2 {
    fn is_initialized(&self) -> bool {
        for v in &self.translation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scale)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.translation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.translation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scale.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TRS2 {
        TRS2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector2>>(
                    "translation",
                    |m: &TRS2| { &m.translation },
                    |m: &mut TRS2| { &mut m.translation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector2>>(
                    "scale",
                    |m: &TRS2| { &m.scale },
                    |m: &mut TRS2| { &mut m.scale },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TRS2>(
                    "TRS2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TRS2 {
        static mut instance: ::protobuf::lazy::Lazy<TRS2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TRS2,
        };
        unsafe {
            instance.get(TRS2::new)
        }
    }
}

impl ::protobuf::Clear for TRS2 {
    fn clear(&mut self) {
        self.translation.clear();
        self.scale.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TRS2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TRS2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TRS3 {
    // message fields
    pub translation: ::protobuf::SingularPtrField<Vector3>,
    pub scale: ::protobuf::SingularPtrField<Vector3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TRS3 {
    fn default() -> &'a TRS3 {
        <TRS3 as ::protobuf::Message>::default_instance()
    }
}

impl TRS3 {
    pub fn new() -> TRS3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Vector3 translation = 1;


    pub fn get_translation(&self) -> &Vector3 {
        self.translation.as_ref().unwrap_or_else(|| Vector3::default_instance())
    }
    pub fn clear_translation(&mut self) {
        self.translation.clear();
    }

    pub fn has_translation(&self) -> bool {
        self.translation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translation(&mut self, v: Vector3) {
        self.translation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translation(&mut self) -> &mut Vector3 {
        if self.translation.is_none() {
            self.translation.set_default();
        }
        self.translation.as_mut().unwrap()
    }

    // Take field
    pub fn take_translation(&mut self) -> Vector3 {
        self.translation.take().unwrap_or_else(|| Vector3::new())
    }

    // .observation_tools.proto.Vector3 scale = 3;


    pub fn get_scale(&self) -> &Vector3 {
        self.scale.as_ref().unwrap_or_else(|| Vector3::default_instance())
    }
    pub fn clear_scale(&mut self) {
        self.scale.clear();
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: Vector3) {
        self.scale = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale(&mut self) -> &mut Vector3 {
        if self.scale.is_none() {
            self.scale.set_default();
        }
        self.scale.as_mut().unwrap()
    }

    // Take field
    pub fn take_scale(&mut self) -> Vector3 {
        self.scale.take().unwrap_or_else(|| Vector3::new())
    }
}

impl ::protobuf::Message for TRS3 {
    fn is_initialized(&self) -> bool {
        for v in &self.translation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scale)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.translation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.translation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scale.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TRS3 {
        TRS3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector3>>(
                    "translation",
                    |m: &TRS3| { &m.translation },
                    |m: &mut TRS3| { &mut m.translation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector3>>(
                    "scale",
                    |m: &TRS3| { &m.scale },
                    |m: &mut TRS3| { &mut m.scale },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TRS3>(
                    "TRS3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TRS3 {
        static mut instance: ::protobuf::lazy::Lazy<TRS3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TRS3,
        };
        unsafe {
            instance.get(TRS3::new)
        }
    }
}

impl ::protobuf::Clear for TRS3 {
    fn clear(&mut self) {
        self.translation.clear();
        self.scale.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TRS3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TRS3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1csrc/api/artifacts/math.proto\x12\x17observation_tools.proto\"\x16\
    \n\x06Number\x12\x0c\n\x01d\x18\x01\x20\x01(\x01R\x01d\"f\n\x06Point2\
    \x12-\n\x01x\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\
    \x01x\x12-\n\x01y\x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.Numb\
    erR\x01y\"t\n\x08Segment2\x125\n\x05start\x18\x01\x20\x01(\x0b2\x1f.obse\
    rvation_tools.proto.Point2R\x05start\x121\n\x03end\x18\x02\x20\x01(\x0b2\
    \x1f.observation_tools.proto.Point2R\x03end\"\x95\x01\n\x06Point3\x12-\n\
    \x01x\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01x\x12\
    -\n\x01y\x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01y\
    \x12-\n\x01z\x18\x03\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\
    \x01z\"g\n\x07Vector2\x12-\n\x01x\x18\x01\x20\x01(\x0b2\x1f.observation_\
    tools.proto.NumberR\x01x\x12-\n\x01y\x18\x02\x20\x01(\x0b2\x1f.observati\
    on_tools.proto.NumberR\x01y\"\x96\x01\n\x07Vector3\x12-\n\x01x\x18\x01\
    \x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01x\x12-\n\x01y\x18\
    \x02\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01y\x12-\n\x01z\
    \x18\x03\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01z\"G\n\x0c\
    PolygonEdge2\x127\n\x06vertex\x18\x01\x20\x01(\x0b2\x1f.observation_tool\
    s.proto.Point2R\x06vertex\"G\n\x08Polygon2\x12;\n\x05edges\x18\x01\x20\
    \x03(\x0b2%.observation_tools.proto.PolygonEdge2R\x05edges\"\xc5\x02\n\
    \x05Graph\x12?\n\x05nodes\x18\x01\x20\x03(\x0b2).observation_tools.proto\
    .Graph.NodesEntryR\x05nodes\x12?\n\x05edges\x18\x02\x20\x03(\x0b2).obser\
    vation_tools.proto.Graph.EdgesEntryR\x05edges\x1a\\\n\nNodesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x128\n\x05value\x18\x02\x20\x01\
    (\x0b2\".observation_tools.proto.GraphNodeR\x05value:\x028\x01\x1a\\\n\n\
    EdgesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x128\n\x05value\
    \x18\x02\x20\x01(\x0b2\".observation_tools.proto.GraphEdgeR\x05value:\
    \x028\x01\"H\n\tGraphNode\x12;\n\x08position\x18\x01\x20\x01(\x0b2\x1f.o\
    bservation_tools.proto.Point3R\x08position\"O\n\tGraphEdge\x12\"\n\rstar\
    t_node_id\x18\x01\x20\x01(\tR\x0bstartNodeId\x12\x1e\n\x0bend_node_id\
    \x18\x02\x20\x01(\tR\tendNodeId\"\xdf\x03\n\tMatrix3x3\x122\n\x04m0_0\
    \x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m00\x122\n\
    \x04m0_1\x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m0\
    1\x122\n\x04m0_2\x18\x03\x20\x01(\x0b2\x1f.observation_tools.proto.Numbe\
    rR\x03m02\x122\n\x04m1_0\x18\x04\x20\x01(\x0b2\x1f.observation_tools.pro\
    to.NumberR\x03m10\x122\n\x04m1_1\x18\x05\x20\x01(\x0b2\x1f.observation_t\
    ools.proto.NumberR\x03m11\x122\n\x04m1_2\x18\x06\x20\x01(\x0b2\x1f.obser\
    vation_tools.proto.NumberR\x03m12\x122\n\x04m2_0\x18\x07\x20\x01(\x0b2\
    \x1f.observation_tools.proto.NumberR\x03m20\x122\n\x04m2_1\x18\x08\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m21\x122\n\x04m2_2\x18\
    \t\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m22\"\xcb\x06\n\
    \tMatrix4x4\x122\n\x04m0_0\x18\x01\x20\x01(\x0b2\x1f.observation_tools.p\
    roto.NumberR\x03m00\x122\n\x04m0_1\x18\x02\x20\x01(\x0b2\x1f.observation\
    _tools.proto.NumberR\x03m01\x122\n\x04m0_2\x18\x03\x20\x01(\x0b2\x1f.obs\
    ervation_tools.proto.NumberR\x03m02\x122\n\x04m0_3\x18\x04\x20\x01(\x0b2\
    \x1f.observation_tools.proto.NumberR\x03m03\x122\n\x04m1_0\x18\x05\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m10\x122\n\x04m1_1\x18\
    \x06\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m11\x122\n\x04\
    m1_2\x18\x07\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m12\
    \x122\n\x04m1_3\x18\x08\x20\x01(\x0b2\x1f.observation_tools.proto.Number\
    R\x03m13\x122\n\x04m2_0\x18\t\x20\x01(\x0b2\x1f.observation_tools.proto.\
    NumberR\x03m20\x122\n\x04m2_1\x18\n\x20\x01(\x0b2\x1f.observation_tools.\
    proto.NumberR\x03m21\x122\n\x04m2_2\x18\x0b\x20\x01(\x0b2\x1f.observatio\
    n_tools.proto.NumberR\x03m22\x122\n\x04m2_3\x18\x0c\x20\x01(\x0b2\x1f.ob\
    servation_tools.proto.NumberR\x03m23\x122\n\x04m3_0\x18\r\x20\x01(\x0b2\
    \x1f.observation_tools.proto.NumberR\x03m30\x122\n\x04m3_1\x18\x0e\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m31\x122\n\x04m3_2\x18\
    \x0f\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m32\x122\n\x04\
    m3_3\x18\x10\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m33\"e\
    \n\nTransform2\x121\n\x03trs\x18\x01\x20\x01(\x0b2\x1d.observation_tools\
    .proto.TRS2H\0R\x03trs\x12\x1c\n\x08identity\x18\x02\x20\x01(\x08H\0R\
    \x08identityB\x06\n\x04data\"\xa3\x01\n\nTransform3\x121\n\x03trs\x18\
    \x01\x20\x01(\x0b2\x1d.observation_tools.proto.TRS3H\0R\x03trs\x12<\n\
    \x06matrix\x18\x02\x20\x01(\x0b2\".observation_tools.proto.Matrix4x4H\0R\
    \x06matrix\x12\x1c\n\x08identity\x18\x03\x20\x01(\x08H\0R\x08identityB\
    \x06\n\x04data\"\x82\x01\n\x04TRS2\x12B\n\x0btranslation\x18\x01\x20\x01\
    (\x0b2\x20.observation_tools.proto.Vector2R\x0btranslation\x126\n\x05sca\
    le\x18\x03\x20\x01(\x0b2\x20.observation_tools.proto.Vector2R\x05scale\"\
    \x82\x01\n\x04TRS3\x12B\n\x0btranslation\x18\x01\x20\x01(\x0b2\x20.obser\
    vation_tools.proto.Vector3R\x0btranslation\x126\n\x05scale\x18\x03\x20\
    \x01(\x0b2\x20.observation_tools.proto.Vector3R\x05scaleB\x1b\n\x17tools\
    .observation.protoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
