// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/api/artifacts/artifact.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactId {
    // message fields
    pub uuid: ::protobuf::SingularPtrField<super::uuid::Uuid>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactId {
    fn default() -> &'a ArtifactId {
        <ArtifactId as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactId {
    pub fn new() -> ArtifactId {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Uuid uuid = 1;


    pub fn get_uuid(&self) -> &super::uuid::Uuid {
        self.uuid.as_ref().unwrap_or_else(|| super::uuid::Uuid::default_instance())
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: super::uuid::Uuid) {
        self.uuid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut super::uuid::Uuid {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> super::uuid::Uuid {
        self.uuid.take().unwrap_or_else(|| super::uuid::Uuid::new())
    }
}

impl ::protobuf::Message for ArtifactId {
    fn is_initialized(&self) -> bool {
        for v in &self.uuid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactId {
        ArtifactId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::uuid::Uuid>>(
                    "uuid",
                    |m: &ArtifactId| { &m.uuid },
                    |m: &mut ArtifactId| { &mut m.uuid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArtifactId>(
                    "ArtifactId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArtifactId {
        static mut instance: ::protobuf::lazy::Lazy<ArtifactId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArtifactId,
        };
        unsafe {
            instance.get(ArtifactId::new)
        }
    }
}

impl ::protobuf::Clear for ArtifactId {
    fn clear(&mut self) {
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactData {
    // message fields
    pub ancestor_group_ids: ::protobuf::RepeatedField<ArtifactId>,
    pub user_metadata: ::protobuf::SingularPtrField<ArtifactUserMetadata>,
    pub artifact_type: ArtifactType,
    pub client_creation_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub type_data: ::std::option::Option<ArtifactData_oneof_type_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactData {
    fn default() -> &'a ArtifactData {
        <ArtifactData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ArtifactData_oneof_type_data {
    run_stage_data(RunStageData),
    map_2d_to_3d(Map2dTo3dData),
    group_3d(Group3d),
}

impl ArtifactData {
    pub fn new() -> ArtifactData {
        ::std::default::Default::default()
    }

    // repeated .observation_tools.proto.ArtifactId ancestor_group_ids = 6;


    pub fn get_ancestor_group_ids(&self) -> &[ArtifactId] {
        &self.ancestor_group_ids
    }
    pub fn clear_ancestor_group_ids(&mut self) {
        self.ancestor_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ancestor_group_ids(&mut self, v: ::protobuf::RepeatedField<ArtifactId>) {
        self.ancestor_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ancestor_group_ids(&mut self) -> &mut ::protobuf::RepeatedField<ArtifactId> {
        &mut self.ancestor_group_ids
    }

    // Take field
    pub fn take_ancestor_group_ids(&mut self) -> ::protobuf::RepeatedField<ArtifactId> {
        ::std::mem::replace(&mut self.ancestor_group_ids, ::protobuf::RepeatedField::new())
    }

    // .observation_tools.proto.ArtifactUserMetadata user_metadata = 7;


    pub fn get_user_metadata(&self) -> &ArtifactUserMetadata {
        self.user_metadata.as_ref().unwrap_or_else(|| ArtifactUserMetadata::default_instance())
    }
    pub fn clear_user_metadata(&mut self) {
        self.user_metadata.clear();
    }

    pub fn has_user_metadata(&self) -> bool {
        self.user_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_metadata(&mut self, v: ArtifactUserMetadata) {
        self.user_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_metadata(&mut self) -> &mut ArtifactUserMetadata {
        if self.user_metadata.is_none() {
            self.user_metadata.set_default();
        }
        self.user_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_metadata(&mut self) -> ArtifactUserMetadata {
        self.user_metadata.take().unwrap_or_else(|| ArtifactUserMetadata::new())
    }

    // .observation_tools.proto.ArtifactType artifact_type = 8;


    pub fn get_artifact_type(&self) -> ArtifactType {
        self.artifact_type
    }
    pub fn clear_artifact_type(&mut self) {
        self.artifact_type = ArtifactType::ARTIFACT_TYPE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_artifact_type(&mut self, v: ArtifactType) {
        self.artifact_type = v;
    }

    // .observation_tools.proto.RunStageData run_stage_data = 9;


    pub fn get_run_stage_data(&self) -> &RunStageData {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(ref v)) => v,
            _ => RunStageData::default_instance(),
        }
    }
    pub fn clear_run_stage_data(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_run_stage_data(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_run_stage_data(&mut self, v: RunStageData) {
        self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_run_stage_data(&mut self) -> &mut RunStageData {
        if let ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(RunStageData::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_run_stage_data(&mut self) -> RunStageData {
        if self.has_run_stage_data() {
            match self.type_data.take() {
                ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(v)) => v,
                _ => panic!(),
            }
        } else {
            RunStageData::new()
        }
    }

    // .observation_tools.proto.Map2dTo3dData map_2d_to_3d = 10;


    pub fn get_map_2d_to_3d(&self) -> &Map2dTo3dData {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(ref v)) => v,
            _ => Map2dTo3dData::default_instance(),
        }
    }
    pub fn clear_map_2d_to_3d(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_map_2d_to_3d(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_2d_to_3d(&mut self, v: Map2dTo3dData) {
        self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_2d_to_3d(&mut self) -> &mut Map2dTo3dData {
        if let ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(Map2dTo3dData::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_2d_to_3d(&mut self) -> Map2dTo3dData {
        if self.has_map_2d_to_3d() {
            match self.type_data.take() {
                ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(v)) => v,
                _ => panic!(),
            }
        } else {
            Map2dTo3dData::new()
        }
    }

    // .observation_tools.proto.Group3d group_3d = 11;


    pub fn get_group_3d(&self) -> &Group3d {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(ref v)) => v,
            _ => Group3d::default_instance(),
        }
    }
    pub fn clear_group_3d(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_group_3d(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group_3d(&mut self, v: Group3d) {
        self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group_3d(&mut self) -> &mut Group3d {
        if let ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(Group3d::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group_3d(&mut self) -> Group3d {
        if self.has_group_3d() {
            match self.type_data.take() {
                ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(v)) => v,
                _ => panic!(),
            }
        } else {
            Group3d::new()
        }
    }

    // .google.protobuf.Timestamp client_creation_time = 5;


    pub fn get_client_creation_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.client_creation_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_client_creation_time(&mut self) {
        self.client_creation_time.clear();
    }

    pub fn has_client_creation_time(&self) -> bool {
        self.client_creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_creation_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.client_creation_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_creation_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.client_creation_time.is_none() {
            self.client_creation_time.set_default();
        }
        self.client_creation_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_creation_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.client_creation_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ArtifactData {
    fn is_initialized(&self) -> bool {
        for v in &self.ancestor_group_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ArtifactData_oneof_type_data::run_stage_data(ref v)) = self.type_data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactData_oneof_type_data::map_2d_to_3d(ref v)) = self.type_data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactData_oneof_type_data::group_3d(ref v)) = self.type_data {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.client_creation_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ancestor_group_ids)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.artifact_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::run_stage_data(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::map_2d_to_3d(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_data = ::std::option::Option::Some(ArtifactData_oneof_type_data::group_3d(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_creation_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ancestor_group_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.user_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.artifact_type != ArtifactType::ARTIFACT_TYPE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(8, self.artifact_type);
        }
        if let Some(ref v) = self.client_creation_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.type_data {
            match v {
                &ArtifactData_oneof_type_data::run_stage_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ArtifactData_oneof_type_data::map_2d_to_3d(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ArtifactData_oneof_type_data::group_3d(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ancestor_group_ids {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.user_metadata.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.artifact_type != ArtifactType::ARTIFACT_TYPE_UNKNOWN {
            os.write_enum(8, self.artifact_type.value())?;
        }
        if let Some(ref v) = self.client_creation_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.type_data {
            match v {
                &ArtifactData_oneof_type_data::run_stage_data(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ArtifactData_oneof_type_data::map_2d_to_3d(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ArtifactData_oneof_type_data::group_3d(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactData {
        ArtifactData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtifactId>>(
                    "ancestor_group_ids",
                    |m: &ArtifactData| { &m.ancestor_group_ids },
                    |m: &mut ArtifactData| { &mut m.ancestor_group_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtifactUserMetadata>>(
                    "user_metadata",
                    |m: &ArtifactData| { &m.user_metadata },
                    |m: &mut ArtifactData| { &mut m.user_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArtifactType>>(
                    "artifact_type",
                    |m: &ArtifactData| { &m.artifact_type },
                    |m: &mut ArtifactData| { &mut m.artifact_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RunStageData>(
                    "run_stage_data",
                    ArtifactData::has_run_stage_data,
                    ArtifactData::get_run_stage_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Map2dTo3dData>(
                    "map_2d_to_3d",
                    ArtifactData::has_map_2d_to_3d,
                    ArtifactData::get_map_2d_to_3d,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Group3d>(
                    "group_3d",
                    ArtifactData::has_group_3d,
                    ArtifactData::get_group_3d,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "client_creation_time",
                    |m: &ArtifactData| { &m.client_creation_time },
                    |m: &mut ArtifactData| { &mut m.client_creation_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArtifactData>(
                    "ArtifactData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArtifactData {
        static mut instance: ::protobuf::lazy::Lazy<ArtifactData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArtifactData,
        };
        unsafe {
            instance.get(ArtifactData::new)
        }
    }
}

impl ::protobuf::Clear for ArtifactData {
    fn clear(&mut self) {
        self.ancestor_group_ids.clear();
        self.user_metadata.clear();
        self.artifact_type = ArtifactType::ARTIFACT_TYPE_UNKNOWN;
        self.type_data = ::std::option::Option::None;
        self.type_data = ::std::option::Option::None;
        self.type_data = ::std::option::Option::None;
        self.client_creation_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactUserMetadata {
    // message fields
    pub name: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactUserMetadata {
    fn default() -> &'a ArtifactUserMetadata {
        <ArtifactUserMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactUserMetadata {
    pub fn new() -> ArtifactUserMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .observation_tools.proto.ArtifactUserMetadata.MetadataEntry metadata = 2;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ArtifactUserMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactUserMetadata {
        ArtifactUserMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ArtifactUserMetadata| { &m.name },
                    |m: &mut ArtifactUserMetadata| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &ArtifactUserMetadata| { &m.metadata },
                    |m: &mut ArtifactUserMetadata| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArtifactUserMetadata>(
                    "ArtifactUserMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArtifactUserMetadata {
        static mut instance: ::protobuf::lazy::Lazy<ArtifactUserMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArtifactUserMetadata,
        };
        unsafe {
            instance.get(ArtifactUserMetadata::new)
        }
    }
}

impl ::protobuf::Clear for ArtifactUserMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactUserMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUserMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunStageData {
    // message fields
    pub previous_run_stage_ids: ::protobuf::RepeatedField<ArtifactId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunStageData {
    fn default() -> &'a RunStageData {
        <RunStageData as ::protobuf::Message>::default_instance()
    }
}

impl RunStageData {
    pub fn new() -> RunStageData {
        ::std::default::Default::default()
    }

    // repeated .observation_tools.proto.ArtifactId previous_run_stage_ids = 1;


    pub fn get_previous_run_stage_ids(&self) -> &[ArtifactId] {
        &self.previous_run_stage_ids
    }
    pub fn clear_previous_run_stage_ids(&mut self) {
        self.previous_run_stage_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_run_stage_ids(&mut self, v: ::protobuf::RepeatedField<ArtifactId>) {
        self.previous_run_stage_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previous_run_stage_ids(&mut self) -> &mut ::protobuf::RepeatedField<ArtifactId> {
        &mut self.previous_run_stage_ids
    }

    // Take field
    pub fn take_previous_run_stage_ids(&mut self) -> ::protobuf::RepeatedField<ArtifactId> {
        ::std::mem::replace(&mut self.previous_run_stage_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RunStageData {
    fn is_initialized(&self) -> bool {
        for v in &self.previous_run_stage_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.previous_run_stage_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.previous_run_stage_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.previous_run_stage_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunStageData {
        RunStageData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtifactId>>(
                    "previous_run_stage_ids",
                    |m: &RunStageData| { &m.previous_run_stage_ids },
                    |m: &mut RunStageData| { &mut m.previous_run_stage_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunStageData>(
                    "RunStageData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunStageData {
        static mut instance: ::protobuf::lazy::Lazy<RunStageData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunStageData,
        };
        unsafe {
            instance.get(RunStageData::new)
        }
    }
}

impl ::protobuf::Clear for RunStageData {
    fn clear(&mut self) {
        self.previous_run_stage_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunStageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunStageData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Map2dTo3dData {
    // message fields
    pub to_3d_transform: ::protobuf::SingularPtrField<super::math::Transform3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Map2dTo3dData {
    fn default() -> &'a Map2dTo3dData {
        <Map2dTo3dData as ::protobuf::Message>::default_instance()
    }
}

impl Map2dTo3dData {
    pub fn new() -> Map2dTo3dData {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Transform3 to_3d_transform = 2;


    pub fn get_to_3d_transform(&self) -> &super::math::Transform3 {
        self.to_3d_transform.as_ref().unwrap_or_else(|| super::math::Transform3::default_instance())
    }
    pub fn clear_to_3d_transform(&mut self) {
        self.to_3d_transform.clear();
    }

    pub fn has_to_3d_transform(&self) -> bool {
        self.to_3d_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_3d_transform(&mut self, v: super::math::Transform3) {
        self.to_3d_transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_3d_transform(&mut self) -> &mut super::math::Transform3 {
        if self.to_3d_transform.is_none() {
            self.to_3d_transform.set_default();
        }
        self.to_3d_transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_3d_transform(&mut self) -> super::math::Transform3 {
        self.to_3d_transform.take().unwrap_or_else(|| super::math::Transform3::new())
    }
}

impl ::protobuf::Message for Map2dTo3dData {
    fn is_initialized(&self) -> bool {
        for v in &self.to_3d_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_3d_transform)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.to_3d_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.to_3d_transform.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Map2dTo3dData {
        Map2dTo3dData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Transform3>>(
                    "to_3d_transform",
                    |m: &Map2dTo3dData| { &m.to_3d_transform },
                    |m: &mut Map2dTo3dData| { &mut m.to_3d_transform },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Map2dTo3dData>(
                    "Map2dTo3dData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Map2dTo3dData {
        static mut instance: ::protobuf::lazy::Lazy<Map2dTo3dData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Map2dTo3dData,
        };
        unsafe {
            instance.get(Map2dTo3dData::new)
        }
    }
}

impl ::protobuf::Clear for Map2dTo3dData {
    fn clear(&mut self) {
        self.to_3d_transform.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Map2dTo3dData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Map2dTo3dData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Group3d {
    // message fields
    pub base_transform: ::protobuf::SingularPtrField<super::math::Transform3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Group3d {
    fn default() -> &'a Group3d {
        <Group3d as ::protobuf::Message>::default_instance()
    }
}

impl Group3d {
    pub fn new() -> Group3d {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Transform3 base_transform = 2;


    pub fn get_base_transform(&self) -> &super::math::Transform3 {
        self.base_transform.as_ref().unwrap_or_else(|| super::math::Transform3::default_instance())
    }
    pub fn clear_base_transform(&mut self) {
        self.base_transform.clear();
    }

    pub fn has_base_transform(&self) -> bool {
        self.base_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_transform(&mut self, v: super::math::Transform3) {
        self.base_transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_transform(&mut self) -> &mut super::math::Transform3 {
        if self.base_transform.is_none() {
            self.base_transform.set_default();
        }
        self.base_transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_transform(&mut self) -> super::math::Transform3 {
        self.base_transform.take().unwrap_or_else(|| super::math::Transform3::new())
    }
}

impl ::protobuf::Message for Group3d {
    fn is_initialized(&self) -> bool {
        for v in &self.base_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_transform)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_transform.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Group3d {
        Group3d::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Transform3>>(
                    "base_transform",
                    |m: &Group3d| { &m.base_transform },
                    |m: &mut Group3d| { &mut m.base_transform },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Group3d>(
                    "Group3d",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Group3d {
        static mut instance: ::protobuf::lazy::Lazy<Group3d> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Group3d,
        };
        unsafe {
            instance.get(Group3d::new)
        }
    }
}

impl ::protobuf::Clear for Group3d {
    fn clear(&mut self) {
        self.base_transform.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Group3d {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group3d {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredData {
    // message oneof groups
    pub data: ::std::option::Option<StructuredData_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StructuredData {
    fn default() -> &'a StructuredData {
        <StructuredData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StructuredData_oneof_data {
    polygon2(super::math::Polygon2),
    graph(super::math::Graph),
    point2(super::math::Point2),
    image2(Image2),
    segment2(super::math::Segment2),
    object3(Object3),
    object2(Object2),
    sphere(Sphere),
}

impl StructuredData {
    pub fn new() -> StructuredData {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Polygon2 polygon2 = 1;


    pub fn get_polygon2(&self) -> &super::math::Polygon2 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::polygon2(ref v)) => v,
            _ => super::math::Polygon2::default_instance(),
        }
    }
    pub fn clear_polygon2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_polygon2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::polygon2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_polygon2(&mut self, v: super::math::Polygon2) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::polygon2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_polygon2(&mut self) -> &mut super::math::Polygon2 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::polygon2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::polygon2(super::math::Polygon2::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::polygon2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_polygon2(&mut self) -> super::math::Polygon2 {
        if self.has_polygon2() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::polygon2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Polygon2::new()
        }
    }

    // .observation_tools.proto.Graph graph = 2;


    pub fn get_graph(&self) -> &super::math::Graph {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::graph(ref v)) => v,
            _ => super::math::Graph::default_instance(),
        }
    }
    pub fn clear_graph(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_graph(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::graph(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_graph(&mut self, v: super::math::Graph) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::graph(v))
    }

    // Mutable pointer to the field.
    pub fn mut_graph(&mut self) -> &mut super::math::Graph {
        if let ::std::option::Option::Some(StructuredData_oneof_data::graph(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::graph(super::math::Graph::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::graph(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_graph(&mut self) -> super::math::Graph {
        if self.has_graph() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::graph(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Graph::new()
        }
    }

    // .observation_tools.proto.Point2 point2 = 3;


    pub fn get_point2(&self) -> &super::math::Point2 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::point2(ref v)) => v,
            _ => super::math::Point2::default_instance(),
        }
    }
    pub fn clear_point2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_point2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::point2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_point2(&mut self, v: super::math::Point2) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::point2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_point2(&mut self) -> &mut super::math::Point2 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::point2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::point2(super::math::Point2::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::point2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_point2(&mut self) -> super::math::Point2 {
        if self.has_point2() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::point2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Point2::new()
        }
    }

    // .observation_tools.proto.Image2 image2 = 4;


    pub fn get_image2(&self) -> &Image2 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::image2(ref v)) => v,
            _ => Image2::default_instance(),
        }
    }
    pub fn clear_image2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_image2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::image2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image2(&mut self, v: Image2) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::image2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image2(&mut self) -> &mut Image2 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::image2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::image2(Image2::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::image2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image2(&mut self) -> Image2 {
        if self.has_image2() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::image2(v)) => v,
                _ => panic!(),
            }
        } else {
            Image2::new()
        }
    }

    // .observation_tools.proto.Segment2 segment2 = 5;


    pub fn get_segment2(&self) -> &super::math::Segment2 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::segment2(ref v)) => v,
            _ => super::math::Segment2::default_instance(),
        }
    }
    pub fn clear_segment2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_segment2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::segment2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_segment2(&mut self, v: super::math::Segment2) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::segment2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_segment2(&mut self) -> &mut super::math::Segment2 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::segment2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::segment2(super::math::Segment2::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::segment2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_segment2(&mut self) -> super::math::Segment2 {
        if self.has_segment2() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::segment2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Segment2::new()
        }
    }

    // .observation_tools.proto.Object3 object3 = 6;


    pub fn get_object3(&self) -> &Object3 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object3(ref v)) => v,
            _ => Object3::default_instance(),
        }
    }
    pub fn clear_object3(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_object3(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object3(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object3(&mut self, v: Object3) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::object3(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object3(&mut self) -> &mut Object3 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::object3(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::object3(Object3::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object3(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object3(&mut self) -> Object3 {
        if self.has_object3() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::object3(v)) => v,
                _ => panic!(),
            }
        } else {
            Object3::new()
        }
    }

    // .observation_tools.proto.Object2 object2 = 7;


    pub fn get_object2(&self) -> &Object2 {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object2(ref v)) => v,
            _ => Object2::default_instance(),
        }
    }
    pub fn clear_object2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_object2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object2(&mut self, v: Object2) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::object2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object2(&mut self) -> &mut Object2 {
        if let ::std::option::Option::Some(StructuredData_oneof_data::object2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::object2(Object2::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::object2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object2(&mut self) -> Object2 {
        if self.has_object2() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::object2(v)) => v,
                _ => panic!(),
            }
        } else {
            Object2::new()
        }
    }

    // .observation_tools.proto.Sphere sphere = 8;


    pub fn get_sphere(&self) -> &Sphere {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::sphere(ref v)) => v,
            _ => Sphere::default_instance(),
        }
    }
    pub fn clear_sphere(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sphere(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::sphere(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sphere(&mut self, v: Sphere) {
        self.data = ::std::option::Option::Some(StructuredData_oneof_data::sphere(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sphere(&mut self) -> &mut Sphere {
        if let ::std::option::Option::Some(StructuredData_oneof_data::sphere(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(StructuredData_oneof_data::sphere(Sphere::new()));
        }
        match self.data {
            ::std::option::Option::Some(StructuredData_oneof_data::sphere(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sphere(&mut self) -> Sphere {
        if self.has_sphere() {
            match self.data.take() {
                ::std::option::Option::Some(StructuredData_oneof_data::sphere(v)) => v,
                _ => panic!(),
            }
        } else {
            Sphere::new()
        }
    }
}

impl ::protobuf::Message for StructuredData {
    fn is_initialized(&self) -> bool {
        if let Some(StructuredData_oneof_data::polygon2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::graph(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::point2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::image2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::segment2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::object3(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::object2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredData_oneof_data::sphere(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::polygon2(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::graph(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::point2(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::image2(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::segment2(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::object3(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::object2(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(StructuredData_oneof_data::sphere(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &StructuredData_oneof_data::polygon2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::graph(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::point2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::image2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::segment2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::object3(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::object2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredData_oneof_data::sphere(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &StructuredData_oneof_data::polygon2(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::graph(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::point2(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::image2(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::segment2(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::object3(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::object2(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredData_oneof_data::sphere(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredData {
        StructuredData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Polygon2>(
                    "polygon2",
                    StructuredData::has_polygon2,
                    StructuredData::get_polygon2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Graph>(
                    "graph",
                    StructuredData::has_graph,
                    StructuredData::get_graph,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Point2>(
                    "point2",
                    StructuredData::has_point2,
                    StructuredData::get_point2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Image2>(
                    "image2",
                    StructuredData::has_image2,
                    StructuredData::get_image2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Segment2>(
                    "segment2",
                    StructuredData::has_segment2,
                    StructuredData::get_segment2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Object3>(
                    "object3",
                    StructuredData::has_object3,
                    StructuredData::get_object3,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Object2>(
                    "object2",
                    StructuredData::has_object2,
                    StructuredData::get_object2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Sphere>(
                    "sphere",
                    StructuredData::has_sphere,
                    StructuredData::get_sphere,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredData>(
                    "StructuredData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredData {
        static mut instance: ::protobuf::lazy::Lazy<StructuredData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredData,
        };
        unsafe {
            instance.get(StructuredData::new)
        }
    }
}

impl ::protobuf::Clear for StructuredData {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image2 {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub mime_type: ::std::string::String,
    pub pixel_to_world_transform: ::protobuf::SingularPtrField<super::math::Matrix3x3>,
    pub pixel_transform: ::protobuf::SingularPtrField<PerPixelTransform>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image2 {
    fn default() -> &'a Image2 {
        <Image2 as ::protobuf::Message>::default_instance()
    }
}

impl Image2 {
    pub fn new() -> Image2 {
        ::std::default::Default::default()
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string mime_type = 5;


    pub fn get_mime_type(&self) -> &str {
        &self.mime_type
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        &mut self.mime_type
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mime_type, ::std::string::String::new())
    }

    // .observation_tools.proto.Matrix3x3 pixel_to_world_transform = 2;


    pub fn get_pixel_to_world_transform(&self) -> &super::math::Matrix3x3 {
        self.pixel_to_world_transform.as_ref().unwrap_or_else(|| super::math::Matrix3x3::default_instance())
    }
    pub fn clear_pixel_to_world_transform(&mut self) {
        self.pixel_to_world_transform.clear();
    }

    pub fn has_pixel_to_world_transform(&self) -> bool {
        self.pixel_to_world_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pixel_to_world_transform(&mut self, v: super::math::Matrix3x3) {
        self.pixel_to_world_transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pixel_to_world_transform(&mut self) -> &mut super::math::Matrix3x3 {
        if self.pixel_to_world_transform.is_none() {
            self.pixel_to_world_transform.set_default();
        }
        self.pixel_to_world_transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_pixel_to_world_transform(&mut self) -> super::math::Matrix3x3 {
        self.pixel_to_world_transform.take().unwrap_or_else(|| super::math::Matrix3x3::new())
    }

    // .observation_tools.proto.PerPixelTransform pixel_transform = 3;


    pub fn get_pixel_transform(&self) -> &PerPixelTransform {
        self.pixel_transform.as_ref().unwrap_or_else(|| PerPixelTransform::default_instance())
    }
    pub fn clear_pixel_transform(&mut self) {
        self.pixel_transform.clear();
    }

    pub fn has_pixel_transform(&self) -> bool {
        self.pixel_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pixel_transform(&mut self, v: PerPixelTransform) {
        self.pixel_transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pixel_transform(&mut self) -> &mut PerPixelTransform {
        if self.pixel_transform.is_none() {
            self.pixel_transform.set_default();
        }
        self.pixel_transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_pixel_transform(&mut self) -> PerPixelTransform {
        self.pixel_transform.take().unwrap_or_else(|| PerPixelTransform::new())
    }
}

impl ::protobuf::Message for Image2 {
    fn is_initialized(&self) -> bool {
        for v in &self.pixel_to_world_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pixel_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mime_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pixel_to_world_transform)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pixel_transform)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if !self.mime_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mime_type);
        }
        if let Some(ref v) = self.pixel_to_world_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pixel_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if !self.mime_type.is_empty() {
            os.write_string(5, &self.mime_type)?;
        }
        if let Some(ref v) = self.pixel_to_world_transform.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pixel_transform.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image2 {
        Image2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Image2| { &m.data },
                    |m: &mut Image2| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mime_type",
                    |m: &Image2| { &m.mime_type },
                    |m: &mut Image2| { &mut m.mime_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Matrix3x3>>(
                    "pixel_to_world_transform",
                    |m: &Image2| { &m.pixel_to_world_transform },
                    |m: &mut Image2| { &mut m.pixel_to_world_transform },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerPixelTransform>>(
                    "pixel_transform",
                    |m: &Image2| { &m.pixel_transform },
                    |m: &mut Image2| { &mut m.pixel_transform },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image2>(
                    "Image2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Image2 {
        static mut instance: ::protobuf::lazy::Lazy<Image2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image2,
        };
        unsafe {
            instance.get(Image2::new)
        }
    }
}

impl ::protobuf::Clear for Image2 {
    fn clear(&mut self) {
        self.data.clear();
        self.mime_type.clear();
        self.pixel_to_world_transform.clear();
        self.pixel_transform.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PerPixelTransform {
    // message fields
    pub random_distinct_color: ::protobuf::SingularPtrField<RandomDistinctColor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerPixelTransform {
    fn default() -> &'a PerPixelTransform {
        <PerPixelTransform as ::protobuf::Message>::default_instance()
    }
}

impl PerPixelTransform {
    pub fn new() -> PerPixelTransform {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.RandomDistinctColor random_distinct_color = 1;


    pub fn get_random_distinct_color(&self) -> &RandomDistinctColor {
        self.random_distinct_color.as_ref().unwrap_or_else(|| RandomDistinctColor::default_instance())
    }
    pub fn clear_random_distinct_color(&mut self) {
        self.random_distinct_color.clear();
    }

    pub fn has_random_distinct_color(&self) -> bool {
        self.random_distinct_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_distinct_color(&mut self, v: RandomDistinctColor) {
        self.random_distinct_color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random_distinct_color(&mut self) -> &mut RandomDistinctColor {
        if self.random_distinct_color.is_none() {
            self.random_distinct_color.set_default();
        }
        self.random_distinct_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_random_distinct_color(&mut self) -> RandomDistinctColor {
        self.random_distinct_color.take().unwrap_or_else(|| RandomDistinctColor::new())
    }
}

impl ::protobuf::Message for PerPixelTransform {
    fn is_initialized(&self) -> bool {
        for v in &self.random_distinct_color {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.random_distinct_color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.random_distinct_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.random_distinct_color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerPixelTransform {
        PerPixelTransform::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RandomDistinctColor>>(
                    "random_distinct_color",
                    |m: &PerPixelTransform| { &m.random_distinct_color },
                    |m: &mut PerPixelTransform| { &mut m.random_distinct_color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerPixelTransform>(
                    "PerPixelTransform",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PerPixelTransform {
        static mut instance: ::protobuf::lazy::Lazy<PerPixelTransform> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerPixelTransform,
        };
        unsafe {
            instance.get(PerPixelTransform::new)
        }
    }
}

impl ::protobuf::Clear for PerPixelTransform {
    fn clear(&mut self) {
        self.random_distinct_color.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerPixelTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerPixelTransform {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandomDistinctColor {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomDistinctColor {
    fn default() -> &'a RandomDistinctColor {
        <RandomDistinctColor as ::protobuf::Message>::default_instance()
    }
}

impl RandomDistinctColor {
    pub fn new() -> RandomDistinctColor {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RandomDistinctColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomDistinctColor {
        RandomDistinctColor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RandomDistinctColor>(
                    "RandomDistinctColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RandomDistinctColor {
        static mut instance: ::protobuf::lazy::Lazy<RandomDistinctColor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RandomDistinctColor,
        };
        unsafe {
            instance.get(RandomDistinctColor::new)
        }
    }
}

impl ::protobuf::Clear for RandomDistinctColor {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomDistinctColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomDistinctColor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Object2 {
    // message fields
    pub geometry: ::protobuf::SingularPtrField<Geometry2>,
    pub transforms: ::protobuf::RepeatedField<super::math::Transform2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Object2 {
    fn default() -> &'a Object2 {
        <Object2 as ::protobuf::Message>::default_instance()
    }
}

impl Object2 {
    pub fn new() -> Object2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Geometry2 geometry = 1;


    pub fn get_geometry(&self) -> &Geometry2 {
        self.geometry.as_ref().unwrap_or_else(|| Geometry2::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: Geometry2) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut Geometry2 {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> Geometry2 {
        self.geometry.take().unwrap_or_else(|| Geometry2::new())
    }

    // repeated .observation_tools.proto.Transform2 transforms = 2;


    pub fn get_transforms(&self) -> &[super::math::Transform2] {
        &self.transforms
    }
    pub fn clear_transforms(&mut self) {
        self.transforms.clear();
    }

    // Param is passed by value, moved
    pub fn set_transforms(&mut self, v: ::protobuf::RepeatedField<super::math::Transform2>) {
        self.transforms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transforms(&mut self) -> &mut ::protobuf::RepeatedField<super::math::Transform2> {
        &mut self.transforms
    }

    // Take field
    pub fn take_transforms(&mut self) -> ::protobuf::RepeatedField<super::math::Transform2> {
        ::std::mem::replace(&mut self.transforms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Object2 {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transforms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transforms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.transforms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.transforms {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Object2 {
        Object2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Geometry2>>(
                    "geometry",
                    |m: &Object2| { &m.geometry },
                    |m: &mut Object2| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Transform2>>(
                    "transforms",
                    |m: &Object2| { &m.transforms },
                    |m: &mut Object2| { &mut m.transforms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Object2>(
                    "Object2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Object2 {
        static mut instance: ::protobuf::lazy::Lazy<Object2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Object2,
        };
        unsafe {
            instance.get(Object2::new)
        }
    }
}

impl ::protobuf::Clear for Object2 {
    fn clear(&mut self) {
        self.geometry.clear();
        self.transforms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Object2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Geometry2 {
    // message oneof groups
    pub data: ::std::option::Option<Geometry2_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Geometry2 {
    fn default() -> &'a Geometry2 {
        <Geometry2 as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Geometry2_oneof_data {
    point2(super::math::Point2),
    polygon2(super::math::Polygon2),
    segment2(super::math::Segment2),
}

impl Geometry2 {
    pub fn new() -> Geometry2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Point2 point2 = 1;


    pub fn get_point2(&self) -> &super::math::Point2 {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::point2(ref v)) => v,
            _ => super::math::Point2::default_instance(),
        }
    }
    pub fn clear_point2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_point2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::point2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_point2(&mut self, v: super::math::Point2) {
        self.data = ::std::option::Option::Some(Geometry2_oneof_data::point2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_point2(&mut self) -> &mut super::math::Point2 {
        if let ::std::option::Option::Some(Geometry2_oneof_data::point2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Geometry2_oneof_data::point2(super::math::Point2::new()));
        }
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::point2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_point2(&mut self) -> super::math::Point2 {
        if self.has_point2() {
            match self.data.take() {
                ::std::option::Option::Some(Geometry2_oneof_data::point2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Point2::new()
        }
    }

    // .observation_tools.proto.Polygon2 polygon2 = 2;


    pub fn get_polygon2(&self) -> &super::math::Polygon2 {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::polygon2(ref v)) => v,
            _ => super::math::Polygon2::default_instance(),
        }
    }
    pub fn clear_polygon2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_polygon2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::polygon2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_polygon2(&mut self, v: super::math::Polygon2) {
        self.data = ::std::option::Option::Some(Geometry2_oneof_data::polygon2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_polygon2(&mut self) -> &mut super::math::Polygon2 {
        if let ::std::option::Option::Some(Geometry2_oneof_data::polygon2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Geometry2_oneof_data::polygon2(super::math::Polygon2::new()));
        }
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::polygon2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_polygon2(&mut self) -> super::math::Polygon2 {
        if self.has_polygon2() {
            match self.data.take() {
                ::std::option::Option::Some(Geometry2_oneof_data::polygon2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Polygon2::new()
        }
    }

    // .observation_tools.proto.Segment2 segment2 = 3;


    pub fn get_segment2(&self) -> &super::math::Segment2 {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::segment2(ref v)) => v,
            _ => super::math::Segment2::default_instance(),
        }
    }
    pub fn clear_segment2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_segment2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::segment2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_segment2(&mut self, v: super::math::Segment2) {
        self.data = ::std::option::Option::Some(Geometry2_oneof_data::segment2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_segment2(&mut self) -> &mut super::math::Segment2 {
        if let ::std::option::Option::Some(Geometry2_oneof_data::segment2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Geometry2_oneof_data::segment2(super::math::Segment2::new()));
        }
        match self.data {
            ::std::option::Option::Some(Geometry2_oneof_data::segment2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_segment2(&mut self) -> super::math::Segment2 {
        if self.has_segment2() {
            match self.data.take() {
                ::std::option::Option::Some(Geometry2_oneof_data::segment2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Segment2::new()
        }
    }
}

impl ::protobuf::Message for Geometry2 {
    fn is_initialized(&self) -> bool {
        if let Some(Geometry2_oneof_data::point2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Geometry2_oneof_data::polygon2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Geometry2_oneof_data::segment2(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Geometry2_oneof_data::point2(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Geometry2_oneof_data::polygon2(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Geometry2_oneof_data::segment2(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Geometry2_oneof_data::point2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Geometry2_oneof_data::polygon2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Geometry2_oneof_data::segment2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Geometry2_oneof_data::point2(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Geometry2_oneof_data::polygon2(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Geometry2_oneof_data::segment2(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Geometry2 {
        Geometry2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Point2>(
                    "point2",
                    Geometry2::has_point2,
                    Geometry2::get_point2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Polygon2>(
                    "polygon2",
                    Geometry2::has_polygon2,
                    Geometry2::get_polygon2,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::math::Segment2>(
                    "segment2",
                    Geometry2::has_segment2,
                    Geometry2::get_segment2,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Geometry2>(
                    "Geometry2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Geometry2 {
        static mut instance: ::protobuf::lazy::Lazy<Geometry2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Geometry2,
        };
        unsafe {
            instance.get(Geometry2::new)
        }
    }
}

impl ::protobuf::Clear for Geometry2 {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Geometry2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geometry2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Object3 {
    // message fields
    pub geometry: ::protobuf::SingularPtrField<Geometry3>,
    pub transforms: ::protobuf::RepeatedField<super::math::Transform3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Object3 {
    fn default() -> &'a Object3 {
        <Object3 as ::protobuf::Message>::default_instance()
    }
}

impl Object3 {
    pub fn new() -> Object3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Geometry3 geometry = 1;


    pub fn get_geometry(&self) -> &Geometry3 {
        self.geometry.as_ref().unwrap_or_else(|| Geometry3::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: Geometry3) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut Geometry3 {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> Geometry3 {
        self.geometry.take().unwrap_or_else(|| Geometry3::new())
    }

    // repeated .observation_tools.proto.Transform3 transforms = 3;


    pub fn get_transforms(&self) -> &[super::math::Transform3] {
        &self.transforms
    }
    pub fn clear_transforms(&mut self) {
        self.transforms.clear();
    }

    // Param is passed by value, moved
    pub fn set_transforms(&mut self, v: ::protobuf::RepeatedField<super::math::Transform3>) {
        self.transforms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transforms(&mut self) -> &mut ::protobuf::RepeatedField<super::math::Transform3> {
        &mut self.transforms
    }

    // Take field
    pub fn take_transforms(&mut self) -> ::protobuf::RepeatedField<super::math::Transform3> {
        ::std::mem::replace(&mut self.transforms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Object3 {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transforms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transforms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.transforms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.transforms {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Object3 {
        Object3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Geometry3>>(
                    "geometry",
                    |m: &Object3| { &m.geometry },
                    |m: &mut Object3| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Transform3>>(
                    "transforms",
                    |m: &Object3| { &m.transforms },
                    |m: &mut Object3| { &mut m.transforms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Object3>(
                    "Object3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Object3 {
        static mut instance: ::protobuf::lazy::Lazy<Object3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Object3,
        };
        unsafe {
            instance.get(Object3::new)
        }
    }
}

impl ::protobuf::Clear for Object3 {
    fn clear(&mut self) {
        self.geometry.clear();
        self.transforms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Object3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Geometry3 {
    // message oneof groups
    pub data: ::std::option::Option<Geometry3_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Geometry3 {
    fn default() -> &'a Geometry3 {
        <Geometry3 as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Geometry3_oneof_data {
    sphere(Sphere),
}

impl Geometry3 {
    pub fn new() -> Geometry3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Sphere sphere = 1;


    pub fn get_sphere(&self) -> &Sphere {
        match self.data {
            ::std::option::Option::Some(Geometry3_oneof_data::sphere(ref v)) => v,
            _ => Sphere::default_instance(),
        }
    }
    pub fn clear_sphere(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sphere(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Geometry3_oneof_data::sphere(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sphere(&mut self, v: Sphere) {
        self.data = ::std::option::Option::Some(Geometry3_oneof_data::sphere(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sphere(&mut self) -> &mut Sphere {
        if let ::std::option::Option::Some(Geometry3_oneof_data::sphere(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Geometry3_oneof_data::sphere(Sphere::new()));
        }
        match self.data {
            ::std::option::Option::Some(Geometry3_oneof_data::sphere(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sphere(&mut self) -> Sphere {
        if self.has_sphere() {
            match self.data.take() {
                ::std::option::Option::Some(Geometry3_oneof_data::sphere(v)) => v,
                _ => panic!(),
            }
        } else {
            Sphere::new()
        }
    }
}

impl ::protobuf::Message for Geometry3 {
    fn is_initialized(&self) -> bool {
        if let Some(Geometry3_oneof_data::sphere(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Geometry3_oneof_data::sphere(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Geometry3_oneof_data::sphere(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Geometry3_oneof_data::sphere(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Geometry3 {
        Geometry3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Sphere>(
                    "sphere",
                    Geometry3::has_sphere,
                    Geometry3::get_sphere,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Geometry3>(
                    "Geometry3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Geometry3 {
        static mut instance: ::protobuf::lazy::Lazy<Geometry3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Geometry3,
        };
        unsafe {
            instance.get(Geometry3::new)
        }
    }
}

impl ::protobuf::Clear for Geometry3 {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Geometry3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geometry3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sphere {
    // message fields
    pub radius: ::protobuf::SingularPtrField<super::math::Number>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sphere {
    fn default() -> &'a Sphere {
        <Sphere as ::protobuf::Message>::default_instance()
    }
}

impl Sphere {
    pub fn new() -> Sphere {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Number radius = 1;


    pub fn get_radius(&self) -> &super::math::Number {
        self.radius.as_ref().unwrap_or_else(|| super::math::Number::default_instance())
    }
    pub fn clear_radius(&mut self) {
        self.radius.clear();
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: super::math::Number) {
        self.radius = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radius(&mut self) -> &mut super::math::Number {
        if self.radius.is_none() {
            self.radius.set_default();
        }
        self.radius.as_mut().unwrap()
    }

    // Take field
    pub fn take_radius(&mut self) -> super::math::Number {
        self.radius.take().unwrap_or_else(|| super::math::Number::new())
    }
}

impl ::protobuf::Message for Sphere {
    fn is_initialized(&self) -> bool {
        for v in &self.radius {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.radius)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.radius.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.radius.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sphere {
        Sphere::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::math::Number>>(
                    "radius",
                    |m: &Sphere| { &m.radius },
                    |m: &mut Sphere| { &mut m.radius },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sphere>(
                    "Sphere",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Sphere {
        static mut instance: ::protobuf::lazy::Lazy<Sphere> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sphere,
        };
        unsafe {
            instance.get(Sphere::new)
        }
    }
}

impl ::protobuf::Clear for Sphere {
    fn clear(&mut self) {
        self.radius.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sphere {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sphere {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SphereReference {
    // message oneof groups
    pub data: ::std::option::Option<SphereReference_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SphereReference {
    fn default() -> &'a SphereReference {
        <SphereReference as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SphereReference_oneof_data {
    artifact_id(ArtifactId),
    sphere(Sphere),
}

impl SphereReference {
    pub fn new() -> SphereReference {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.ArtifactId artifact_id = 1;


    pub fn get_artifact_id(&self) -> &ArtifactId {
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(ref v)) => v,
            _ => ArtifactId::default_instance(),
        }
    }
    pub fn clear_artifact_id(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_artifact_id(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_id(&mut self, v: ArtifactId) {
        self.data = ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_id(&mut self) -> &mut ArtifactId {
        if let ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(ArtifactId::new()));
        }
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_id(&mut self) -> ArtifactId {
        if self.has_artifact_id() {
            match self.data.take() {
                ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtifactId::new()
        }
    }

    // .observation_tools.proto.Sphere sphere = 2;


    pub fn get_sphere(&self) -> &Sphere {
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::sphere(ref v)) => v,
            _ => Sphere::default_instance(),
        }
    }
    pub fn clear_sphere(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sphere(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::sphere(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sphere(&mut self, v: Sphere) {
        self.data = ::std::option::Option::Some(SphereReference_oneof_data::sphere(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sphere(&mut self) -> &mut Sphere {
        if let ::std::option::Option::Some(SphereReference_oneof_data::sphere(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(SphereReference_oneof_data::sphere(Sphere::new()));
        }
        match self.data {
            ::std::option::Option::Some(SphereReference_oneof_data::sphere(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sphere(&mut self) -> Sphere {
        if self.has_sphere() {
            match self.data.take() {
                ::std::option::Option::Some(SphereReference_oneof_data::sphere(v)) => v,
                _ => panic!(),
            }
        } else {
            Sphere::new()
        }
    }
}

impl ::protobuf::Message for SphereReference {
    fn is_initialized(&self) -> bool {
        if let Some(SphereReference_oneof_data::artifact_id(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SphereReference_oneof_data::sphere(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(SphereReference_oneof_data::artifact_id(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(SphereReference_oneof_data::sphere(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &SphereReference_oneof_data::artifact_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SphereReference_oneof_data::sphere(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &SphereReference_oneof_data::artifact_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SphereReference_oneof_data::sphere(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SphereReference {
        SphereReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArtifactId>(
                    "artifact_id",
                    SphereReference::has_artifact_id,
                    SphereReference::get_artifact_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Sphere>(
                    "sphere",
                    SphereReference::has_sphere,
                    SphereReference::get_sphere,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SphereReference>(
                    "SphereReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SphereReference {
        static mut instance: ::protobuf::lazy::Lazy<SphereReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SphereReference,
        };
        unsafe {
            instance.get(SphereReference::new)
        }
    }
}

impl ::protobuf::Clear for SphereReference {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SphereReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SphereReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactUpdate {
    // message fields
    pub field_data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub field: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactUpdate {
    fn default() -> &'a ArtifactUpdate {
        <ArtifactUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactUpdate {
    pub fn new() -> ArtifactUpdate {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any field_data = 1;


    pub fn get_field_data(&self) -> &::protobuf::well_known_types::Any {
        self.field_data.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_field_data(&mut self) {
        self.field_data.clear();
    }

    pub fn has_field_data(&self) -> bool {
        self.field_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_data(&mut self, v: ::protobuf::well_known_types::Any) {
        self.field_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_data(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.field_data.is_none() {
            self.field_data.set_default();
        }
        self.field_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_data(&mut self) -> ::protobuf::well_known_types::Any {
        self.field_data.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.FieldMask field = 2;


    pub fn get_field(&self) -> &::protobuf::well_known_types::FieldMask {
        self.field.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.field = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.field.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for ArtifactUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.field_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactUpdate {
        ArtifactUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "field_data",
                    |m: &ArtifactUpdate| { &m.field_data },
                    |m: &mut ArtifactUpdate| { &mut m.field_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "field",
                    |m: &ArtifactUpdate| { &m.field },
                    |m: &mut ArtifactUpdate| { &mut m.field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArtifactUpdate>(
                    "ArtifactUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArtifactUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ArtifactUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArtifactUpdate,
        };
        unsafe {
            instance.get(ArtifactUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ArtifactUpdate {
    fn clear(&mut self) {
        self.field_data.clear();
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArtifactUpdate_Operation {
    OPERATION_UNKNOWN = 0,
    OPERATION_CREATE = 1,
}

impl ::protobuf::ProtobufEnum for ArtifactUpdate_Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtifactUpdate_Operation> {
        match value {
            0 => ::std::option::Option::Some(ArtifactUpdate_Operation::OPERATION_UNKNOWN),
            1 => ::std::option::Option::Some(ArtifactUpdate_Operation::OPERATION_CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArtifactUpdate_Operation] = &[
            ArtifactUpdate_Operation::OPERATION_UNKNOWN,
            ArtifactUpdate_Operation::OPERATION_CREATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ArtifactUpdate_Operation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ArtifactUpdate_Operation {
}

impl ::std::default::Default for ArtifactUpdate_Operation {
    fn default() -> Self {
        ArtifactUpdate_Operation::OPERATION_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUpdate_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArtifactType {
    ARTIFACT_TYPE_UNKNOWN = 0,
    ARTIFACT_TYPE_GENERIC = 1,
    ARTIFACT_TYPE_2D_GROUP = 2,
    ARTIFACT_TYPE_3D_GROUP = 3,
    ARTIFACT_TYPE_2D_IN_3D_GROUP = 4,
    ARTIFACT_TYPE_RUN_STAGE = 5,
    ARTIFACT_TYPE_ROOT_GROUP = 6,
}

impl ::protobuf::ProtobufEnum for ArtifactType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtifactType> {
        match value {
            0 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_GENERIC),
            2 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_2D_GROUP),
            3 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_3D_GROUP),
            4 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_2D_IN_3D_GROUP),
            5 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_RUN_STAGE),
            6 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_ROOT_GROUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArtifactType] = &[
            ArtifactType::ARTIFACT_TYPE_UNKNOWN,
            ArtifactType::ARTIFACT_TYPE_GENERIC,
            ArtifactType::ARTIFACT_TYPE_2D_GROUP,
            ArtifactType::ARTIFACT_TYPE_3D_GROUP,
            ArtifactType::ARTIFACT_TYPE_2D_IN_3D_GROUP,
            ArtifactType::ARTIFACT_TYPE_RUN_STAGE,
            ArtifactType::ARTIFACT_TYPE_ROOT_GROUP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ArtifactType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ArtifactType {
}

impl ::std::default::Default for ArtifactType {
    fn default() -> Self {
        ArtifactType::ARTIFACT_TYPE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20src/api/artifacts/artifact.proto\x12\x17observation_tools.proto\
    \x1a\x1csrc/api/artifacts/uuid.proto\x1a\x1csrc/api/artifacts/math.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19google/protobuf/any.proto\
    \x1a\x20google/protobuf/field_mask.proto\"?\n\nArtifactId\x121\n\x04uuid\
    \x18\x01\x20\x01(\x0b2\x1d.observation_tools.proto.UuidR\x04uuid\"\xbb\
    \x04\n\x0cArtifactData\x12Q\n\x12ancestor_group_ids\x18\x06\x20\x03(\x0b\
    2#.observation_tools.proto.ArtifactIdR\x10ancestorGroupIds\x12R\n\ruser_\
    metadata\x18\x07\x20\x01(\x0b2-.observation_tools.proto.ArtifactUserMeta\
    dataR\x0cuserMetadata\x12J\n\rartifact_type\x18\x08\x20\x01(\x0e2%.obser\
    vation_tools.proto.ArtifactTypeR\x0cartifactType\x12M\n\x0erun_stage_dat\
    a\x18\t\x20\x01(\x0b2%.observation_tools.proto.RunStageDataH\0R\x0crunSt\
    ageData\x12I\n\x0cmap_2d_to_3d\x18\n\x20\x01(\x0b2&.observation_tools.pr\
    oto.Map2dTo3dDataH\0R\tmap2dTo3d\x12=\n\x08group_3d\x18\x0b\x20\x01(\x0b\
    2\x20.observation_tools.proto.Group3dH\0R\x07group3d\x12L\n\x14client_cr\
    eation_time\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x12clie\
    ntCreationTimeB\x0b\n\ttype_dataJ\x04\x08\x01\x10\x05\"\xc0\x01\n\x14Art\
    ifactUserMetadata\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12W\n\
    \x08metadata\x18\x02\x20\x03(\x0b2;.observation_tools.proto.ArtifactUser\
    Metadata.MetadataEntryR\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\"h\n\x0cRunStageData\x12X\n\x16previous_run_stage_ids\
    \x18\x01\x20\x03(\x0b2#.observation_tools.proto.ArtifactIdR\x13previousR\
    unStageIds\"b\n\rMap2dTo3dData\x12K\n\x0fto_3d_transform\x18\x02\x20\x01\
    (\x0b2#.observation_tools.proto.Transform3R\rto3dTransformJ\x04\x08\x01\
    \x10\x02\"[\n\x07Group3d\x12J\n\x0ebase_transform\x18\x02\x20\x01(\x0b2#\
    .observation_tools.proto.Transform3R\rbaseTransformJ\x04\x08\x01\x10\x02\
    \"\xff\x03\n\x0eStructuredData\x12?\n\x08polygon2\x18\x01\x20\x01(\x0b2!\
    .observation_tools.proto.Polygon2H\0R\x08polygon2\x126\n\x05graph\x18\
    \x02\x20\x01(\x0b2\x1e.observation_tools.proto.GraphH\0R\x05graph\x129\n\
    \x06point2\x18\x03\x20\x01(\x0b2\x1f.observation_tools.proto.Point2H\0R\
    \x06point2\x129\n\x06image2\x18\x04\x20\x01(\x0b2\x1f.observation_tools.\
    proto.Image2H\0R\x06image2\x12?\n\x08segment2\x18\x05\x20\x01(\x0b2!.obs\
    ervation_tools.proto.Segment2H\0R\x08segment2\x12<\n\x07object3\x18\x06\
    \x20\x01(\x0b2\x20.observation_tools.proto.Object3H\0R\x07object3\x12<\n\
    \x07object2\x18\x07\x20\x01(\x0b2\x20.observation_tools.proto.Object2H\0\
    R\x07object2\x129\n\x06sphere\x18\x08\x20\x01(\x0b2\x1f.observation_tool\
    s.proto.SphereH\0R\x06sphereB\x06\n\x04data\"\xf1\x01\n\x06Image2\x12\
    \x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\x12\x1b\n\tmime_type\x18\
    \x05\x20\x01(\tR\x08mimeType\x12[\n\x18pixel_to_world_transform\x18\x02\
    \x20\x01(\x0b2\".observation_tools.proto.Matrix3x3R\x15pixelToWorldTrans\
    form\x12S\n\x0fpixel_transform\x18\x03\x20\x01(\x0b2*.observation_tools.\
    proto.PerPixelTransformR\x0epixelTransformJ\x04\x08\x01\x10\x02\"u\n\x11\
    PerPixelTransform\x12`\n\x15random_distinct_color\x18\x01\x20\x01(\x0b2,\
    .observation_tools.proto.RandomDistinctColorR\x13randomDistinctColor\"\
    \x15\n\x13RandomDistinctColor\"\x8e\x01\n\x07Object2\x12>\n\x08geometry\
    \x18\x01\x20\x01(\x0b2\".observation_tools.proto.Geometry2R\x08geometry\
    \x12C\n\ntransforms\x18\x02\x20\x03(\x0b2#.observation_tools.proto.Trans\
    form2R\ntransforms\"\xd0\x01\n\tGeometry2\x129\n\x06point2\x18\x01\x20\
    \x01(\x0b2\x1f.observation_tools.proto.Point2H\0R\x06point2\x12?\n\x08po\
    lygon2\x18\x02\x20\x01(\x0b2!.observation_tools.proto.Polygon2H\0R\x08po\
    lygon2\x12?\n\x08segment2\x18\x03\x20\x01(\x0b2!.observation_tools.proto\
    .Segment2H\0R\x08segment2B\x06\n\x04data\"\x94\x01\n\x07Object3\x12>\n\
    \x08geometry\x18\x01\x20\x01(\x0b2\".observation_tools.proto.Geometry3R\
    \x08geometry\x12C\n\ntransforms\x18\x03\x20\x03(\x0b2#.observation_tools\
    .proto.Transform3R\ntransformsJ\x04\x08\x02\x10\x03\"N\n\tGeometry3\x129\
    \n\x06sphere\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.SphereH\0\
    R\x06sphereB\x06\n\x04data\"A\n\x06Sphere\x127\n\x06radius\x18\x01\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x06radius\"\x9c\x01\n\x0f\
    SphereReference\x12F\n\x0bartifact_id\x18\x01\x20\x01(\x0b2#.observation\
    _tools.proto.ArtifactIdH\0R\nartifactId\x129\n\x06sphere\x18\x02\x20\x01\
    (\x0b2\x1f.observation_tools.proto.SphereH\0R\x06sphereB\x06\n\x04data\"\
    \xb1\x01\n\x0eArtifactUpdate\x123\n\nfield_data\x18\x01\x20\x01(\x0b2\
    \x14.google.protobuf.AnyR\tfieldData\x120\n\x05field\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.FieldMaskR\x05field\"8\n\tOperation\x12\x15\n\
    \x11OPERATION_UNKNOWN\x10\0\x12\x14\n\x10OPERATION_CREATE\x10\x01*\xd9\
    \x01\n\x0cArtifactType\x12\x19\n\x15ARTIFACT_TYPE_UNKNOWN\x10\0\x12\x19\
    \n\x15ARTIFACT_TYPE_GENERIC\x10\x01\x12\x1a\n\x16ARTIFACT_TYPE_2D_GROUP\
    \x10\x02\x12\x1a\n\x16ARTIFACT_TYPE_3D_GROUP\x10\x03\x12\x20\n\x1cARTIFA\
    CT_TYPE_2D_IN_3D_GROUP\x10\x04\x12\x1b\n\x17ARTIFACT_TYPE_RUN_STAGE\x10\
    \x05\x12\x1c\n\x18ARTIFACT_TYPE_ROOT_GROUP\x10\x06B\x1b\n\x17tools.obser\
    vation.protoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
