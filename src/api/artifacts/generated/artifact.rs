// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/api/artifacts/artifact.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.ArtifactId)
pub struct ArtifactId {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactId.uuid)
    pub uuid: ::protobuf::MessageField<super::uuid::Uuid>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.ArtifactId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactId {
    fn default() -> &'a ArtifactId {
        <ArtifactId as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactId {
    pub fn new() -> ArtifactId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::uuid::Uuid>(
            "uuid",
            |m: &ArtifactId| { &m.uuid },
            |m: &mut ArtifactId| { &mut m.uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactId>(
            "ArtifactId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactId {
    const NAME: &'static str = "ArtifactId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.uuid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uuid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uuid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactId {
        ArtifactId::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactId {
        static instance: ArtifactId = ArtifactId {
            uuid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.ArtifactData)
pub struct ArtifactData {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactData.ancestor_group_ids)
    pub ancestor_group_ids: ::std::vec::Vec<ArtifactId>,
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactData.user_metadata)
    pub user_metadata: ::protobuf::MessageField<ArtifactUserMetadata>,
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactData.artifact_type)
    pub artifact_type: ::protobuf::EnumOrUnknown<ArtifactType>,
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactData.client_creation_time)
    pub client_creation_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // message oneof groups
    pub type_data: ::std::option::Option<artifact_data::Type_data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.ArtifactData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactData {
    fn default() -> &'a ArtifactData {
        <ArtifactData as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactData {
    pub fn new() -> ArtifactData {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.RunStageData run_stage_data = 9;

    pub fn run_stage_data(&self) -> &RunStageData {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::RunStageData(ref v)) => v,
            _ => <RunStageData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_run_stage_data(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_run_stage_data(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::RunStageData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_run_stage_data(&mut self, v: RunStageData) {
        self.type_data = ::std::option::Option::Some(artifact_data::Type_data::RunStageData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_run_stage_data(&mut self) -> &mut RunStageData {
        if let ::std::option::Option::Some(artifact_data::Type_data::RunStageData(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(artifact_data::Type_data::RunStageData(RunStageData::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::RunStageData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_run_stage_data(&mut self) -> RunStageData {
        if self.has_run_stage_data() {
            match self.type_data.take() {
                ::std::option::Option::Some(artifact_data::Type_data::RunStageData(v)) => v,
                _ => panic!(),
            }
        } else {
            RunStageData::new()
        }
    }

    // .observation_tools.proto.Map2dTo3dData map_2d_to_3d = 10;

    pub fn map_2d_to_3d(&self) -> &Map2dTo3dData {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(ref v)) => v,
            _ => <Map2dTo3dData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_map_2d_to_3d(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_map_2d_to_3d(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_2d_to_3d(&mut self, v: Map2dTo3dData) {
        self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_2d_to_3d(&mut self) -> &mut Map2dTo3dData {
        if let ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(Map2dTo3dData::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_2d_to_3d(&mut self) -> Map2dTo3dData {
        if self.has_map_2d_to_3d() {
            match self.type_data.take() {
                ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(v)) => v,
                _ => panic!(),
            }
        } else {
            Map2dTo3dData::new()
        }
    }

    // .observation_tools.proto.Group3d group_3d = 11;

    pub fn group_3d(&self) -> &Group3d {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Group3d(ref v)) => v,
            _ => <Group3d as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_group_3d(&mut self) {
        self.type_data = ::std::option::Option::None;
    }

    pub fn has_group_3d(&self) -> bool {
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Group3d(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group_3d(&mut self, v: Group3d) {
        self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Group3d(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group_3d(&mut self) -> &mut Group3d {
        if let ::std::option::Option::Some(artifact_data::Type_data::Group3d(_)) = self.type_data {
        } else {
            self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Group3d(Group3d::new()));
        }
        match self.type_data {
            ::std::option::Option::Some(artifact_data::Type_data::Group3d(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group_3d(&mut self) -> Group3d {
        if self.has_group_3d() {
            match self.type_data.take() {
                ::std::option::Option::Some(artifact_data::Type_data::Group3d(v)) => v,
                _ => panic!(),
            }
        } else {
            Group3d::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ancestor_group_ids",
            |m: &ArtifactData| { &m.ancestor_group_ids },
            |m: &mut ArtifactData| { &mut m.ancestor_group_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArtifactUserMetadata>(
            "user_metadata",
            |m: &ArtifactData| { &m.user_metadata },
            |m: &mut ArtifactData| { &mut m.user_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "artifact_type",
            |m: &ArtifactData| { &m.artifact_type },
            |m: &mut ArtifactData| { &mut m.artifact_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RunStageData>(
            "run_stage_data",
            ArtifactData::has_run_stage_data,
            ArtifactData::run_stage_data,
            ArtifactData::mut_run_stage_data,
            ArtifactData::set_run_stage_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Map2dTo3dData>(
            "map_2d_to_3d",
            ArtifactData::has_map_2d_to_3d,
            ArtifactData::map_2d_to_3d,
            ArtifactData::mut_map_2d_to_3d,
            ArtifactData::set_map_2d_to_3d,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Group3d>(
            "group_3d",
            ArtifactData::has_group_3d,
            ArtifactData::group_3d,
            ArtifactData::mut_group_3d,
            ArtifactData::set_group_3d,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "client_creation_time",
            |m: &ArtifactData| { &m.client_creation_time },
            |m: &mut ArtifactData| { &mut m.client_creation_time },
        ));
        oneofs.push(artifact_data::Type_data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactData>(
            "ArtifactData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactData {
    const NAME: &'static str = "ArtifactData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.ancestor_group_ids.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_metadata)?;
                },
                64 => {
                    self.artifact_type = is.read_enum_or_unknown()?;
                },
                74 => {
                    self.type_data = ::std::option::Option::Some(artifact_data::Type_data::RunStageData(is.read_message()?));
                },
                82 => {
                    self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Map2dTo3d(is.read_message()?));
                },
                90 => {
                    self.type_data = ::std::option::Option::Some(artifact_data::Type_data::Group3d(is.read_message()?));
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_creation_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ancestor_group_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.user_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.artifact_type != ::protobuf::EnumOrUnknown::new(ArtifactType::ARTIFACT_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(8, self.artifact_type.value());
        }
        if let Some(v) = self.client_creation_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.type_data {
            match v {
                &artifact_data::Type_data::RunStageData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &artifact_data::Type_data::Map2dTo3d(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &artifact_data::Type_data::Group3d(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ancestor_group_ids {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.user_metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.artifact_type != ::protobuf::EnumOrUnknown::new(ArtifactType::ARTIFACT_TYPE_UNKNOWN) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.artifact_type))?;
        }
        if let Some(v) = self.client_creation_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.type_data {
            match v {
                &artifact_data::Type_data::RunStageData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &artifact_data::Type_data::Map2dTo3d(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &artifact_data::Type_data::Group3d(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactData {
        ArtifactData::new()
    }

    fn clear(&mut self) {
        self.ancestor_group_ids.clear();
        self.user_metadata.clear();
        self.artifact_type = ::protobuf::EnumOrUnknown::new(ArtifactType::ARTIFACT_TYPE_UNKNOWN);
        self.type_data = ::std::option::Option::None;
        self.type_data = ::std::option::Option::None;
        self.type_data = ::std::option::Option::None;
        self.client_creation_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactData {
        static instance: ArtifactData = ArtifactData {
            ancestor_group_ids: ::std::vec::Vec::new(),
            user_metadata: ::protobuf::MessageField::none(),
            artifact_type: ::protobuf::EnumOrUnknown::from_i32(0),
            client_creation_time: ::protobuf::MessageField::none(),
            type_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ArtifactData`
pub mod artifact_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.ArtifactData.type_data)
    pub enum Type_data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.ArtifactData.run_stage_data)
        RunStageData(super::RunStageData),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.ArtifactData.map_2d_to_3d)
        Map2dTo3d(super::Map2dTo3dData),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.ArtifactData.group_3d)
        Group3d(super::Group3d),
    }

    impl ::protobuf::Oneof for Type_data {
    }

    impl ::protobuf::OneofFull for Type_data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ArtifactData as ::protobuf::MessageFull>::descriptor().oneof_by_name("type_data").unwrap()).clone()
        }
    }

    impl Type_data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type_data>("type_data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.ArtifactUserMetadata)
pub struct ArtifactUserMetadata {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactUserMetadata.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactUserMetadata.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.ArtifactUserMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactUserMetadata {
    fn default() -> &'a ArtifactUserMetadata {
        <ArtifactUserMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactUserMetadata {
    pub fn new() -> ArtifactUserMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ArtifactUserMetadata| { &m.name },
            |m: &mut ArtifactUserMetadata| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &ArtifactUserMetadata| { &m.metadata },
            |m: &mut ArtifactUserMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactUserMetadata>(
            "ArtifactUserMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactUserMetadata {
    const NAME: &'static str = "ArtifactUserMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactUserMetadata {
        ArtifactUserMetadata::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactUserMetadata {
        static instance: ::protobuf::rt::Lazy<ArtifactUserMetadata> = ::protobuf::rt::Lazy::new();
        instance.get(ArtifactUserMetadata::new)
    }
}

impl ::protobuf::MessageFull for ArtifactUserMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactUserMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactUserMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUserMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.RunStageData)
pub struct RunStageData {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.RunStageData.previous_run_stage_ids)
    pub previous_run_stage_ids: ::std::vec::Vec<ArtifactId>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.RunStageData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunStageData {
    fn default() -> &'a RunStageData {
        <RunStageData as ::protobuf::Message>::default_instance()
    }
}

impl RunStageData {
    pub fn new() -> RunStageData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previous_run_stage_ids",
            |m: &RunStageData| { &m.previous_run_stage_ids },
            |m: &mut RunStageData| { &mut m.previous_run_stage_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunStageData>(
            "RunStageData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunStageData {
    const NAME: &'static str = "RunStageData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.previous_run_stage_ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.previous_run_stage_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.previous_run_stage_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunStageData {
        RunStageData::new()
    }

    fn clear(&mut self) {
        self.previous_run_stage_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunStageData {
        static instance: RunStageData = RunStageData {
            previous_run_stage_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunStageData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunStageData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunStageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunStageData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Map2dTo3dData)
pub struct Map2dTo3dData {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Map2dTo3dData.to_3d_transform)
    pub to_3d_transform: ::protobuf::MessageField<super::math::Transform3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Map2dTo3dData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Map2dTo3dData {
    fn default() -> &'a Map2dTo3dData {
        <Map2dTo3dData as ::protobuf::Message>::default_instance()
    }
}

impl Map2dTo3dData {
    pub fn new() -> Map2dTo3dData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Transform3>(
            "to_3d_transform",
            |m: &Map2dTo3dData| { &m.to_3d_transform },
            |m: &mut Map2dTo3dData| { &mut m.to_3d_transform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Map2dTo3dData>(
            "Map2dTo3dData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Map2dTo3dData {
    const NAME: &'static str = "Map2dTo3dData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_3d_transform)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.to_3d_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.to_3d_transform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Map2dTo3dData {
        Map2dTo3dData::new()
    }

    fn clear(&mut self) {
        self.to_3d_transform.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Map2dTo3dData {
        static instance: Map2dTo3dData = Map2dTo3dData {
            to_3d_transform: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Map2dTo3dData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Map2dTo3dData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Map2dTo3dData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Map2dTo3dData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Group3d)
pub struct Group3d {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Group3d.base_transform)
    pub base_transform: ::protobuf::MessageField<super::math::Transform3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Group3d.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Group3d {
    fn default() -> &'a Group3d {
        <Group3d as ::protobuf::Message>::default_instance()
    }
}

impl Group3d {
    pub fn new() -> Group3d {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Transform3>(
            "base_transform",
            |m: &Group3d| { &m.base_transform },
            |m: &mut Group3d| { &mut m.base_transform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Group3d>(
            "Group3d",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Group3d {
    const NAME: &'static str = "Group3d";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_transform)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_transform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Group3d {
        Group3d::new()
    }

    fn clear(&mut self) {
        self.base_transform.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Group3d {
        static instance: Group3d = Group3d {
            base_transform: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Group3d {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Group3d").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Group3d {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group3d {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.StructuredData)
pub struct StructuredData {
    // message oneof groups
    pub data: ::std::option::Option<structured_data::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.StructuredData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StructuredData {
    fn default() -> &'a StructuredData {
        <StructuredData as ::protobuf::Message>::default_instance()
    }
}

impl StructuredData {
    pub fn new() -> StructuredData {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Polygon2 polygon2 = 1;

    pub fn polygon2(&self) -> &super::math::Polygon2 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Polygon2(ref v)) => v,
            _ => <super::math::Polygon2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_polygon2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_polygon2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Polygon2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_polygon2(&mut self, v: super::math::Polygon2) {
        self.data = ::std::option::Option::Some(structured_data::Data::Polygon2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_polygon2(&mut self) -> &mut super::math::Polygon2 {
        if let ::std::option::Option::Some(structured_data::Data::Polygon2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Polygon2(super::math::Polygon2::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Polygon2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_polygon2(&mut self) -> super::math::Polygon2 {
        if self.has_polygon2() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Polygon2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Polygon2::new()
        }
    }

    // .observation_tools.proto.Graph graph = 2;

    pub fn graph(&self) -> &super::math::Graph {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Graph(ref v)) => v,
            _ => <super::math::Graph as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_graph(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_graph(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Graph(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_graph(&mut self, v: super::math::Graph) {
        self.data = ::std::option::Option::Some(structured_data::Data::Graph(v))
    }

    // Mutable pointer to the field.
    pub fn mut_graph(&mut self) -> &mut super::math::Graph {
        if let ::std::option::Option::Some(structured_data::Data::Graph(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Graph(super::math::Graph::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Graph(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_graph(&mut self) -> super::math::Graph {
        if self.has_graph() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Graph(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Graph::new()
        }
    }

    // .observation_tools.proto.Point2 point2 = 3;

    pub fn point2(&self) -> &super::math::Point2 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Point2(ref v)) => v,
            _ => <super::math::Point2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_point2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_point2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Point2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_point2(&mut self, v: super::math::Point2) {
        self.data = ::std::option::Option::Some(structured_data::Data::Point2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_point2(&mut self) -> &mut super::math::Point2 {
        if let ::std::option::Option::Some(structured_data::Data::Point2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Point2(super::math::Point2::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Point2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_point2(&mut self) -> super::math::Point2 {
        if self.has_point2() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Point2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Point2::new()
        }
    }

    // .observation_tools.proto.Image2 image2 = 4;

    pub fn image2(&self) -> &Image2 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Image2(ref v)) => v,
            _ => <Image2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_image2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_image2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Image2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image2(&mut self, v: Image2) {
        self.data = ::std::option::Option::Some(structured_data::Data::Image2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image2(&mut self) -> &mut Image2 {
        if let ::std::option::Option::Some(structured_data::Data::Image2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Image2(Image2::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Image2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image2(&mut self) -> Image2 {
        if self.has_image2() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Image2(v)) => v,
                _ => panic!(),
            }
        } else {
            Image2::new()
        }
    }

    // .observation_tools.proto.Segment2 segment2 = 5;

    pub fn segment2(&self) -> &super::math::Segment2 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Segment2(ref v)) => v,
            _ => <super::math::Segment2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_segment2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_segment2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Segment2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_segment2(&mut self, v: super::math::Segment2) {
        self.data = ::std::option::Option::Some(structured_data::Data::Segment2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_segment2(&mut self) -> &mut super::math::Segment2 {
        if let ::std::option::Option::Some(structured_data::Data::Segment2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Segment2(super::math::Segment2::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Segment2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_segment2(&mut self) -> super::math::Segment2 {
        if self.has_segment2() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Segment2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Segment2::new()
        }
    }

    // .observation_tools.proto.Object3 object3 = 6;

    pub fn object3(&self) -> &Object3 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object3(ref v)) => v,
            _ => <Object3 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_object3(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_object3(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object3(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object3(&mut self, v: Object3) {
        self.data = ::std::option::Option::Some(structured_data::Data::Object3(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object3(&mut self) -> &mut Object3 {
        if let ::std::option::Option::Some(structured_data::Data::Object3(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Object3(Object3::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object3(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object3(&mut self) -> Object3 {
        if self.has_object3() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Object3(v)) => v,
                _ => panic!(),
            }
        } else {
            Object3::new()
        }
    }

    // .observation_tools.proto.Object2 object2 = 7;

    pub fn object2(&self) -> &Object2 {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object2(ref v)) => v,
            _ => <Object2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_object2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_object2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object2(&mut self, v: Object2) {
        self.data = ::std::option::Option::Some(structured_data::Data::Object2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object2(&mut self) -> &mut Object2 {
        if let ::std::option::Option::Some(structured_data::Data::Object2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Object2(Object2::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Object2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object2(&mut self) -> Object2 {
        if self.has_object2() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Object2(v)) => v,
                _ => panic!(),
            }
        } else {
            Object2::new()
        }
    }

    // .observation_tools.proto.Sphere sphere = 8;

    pub fn sphere(&self) -> &Sphere {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Sphere(ref v)) => v,
            _ => <Sphere as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sphere(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sphere(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Sphere(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sphere(&mut self, v: Sphere) {
        self.data = ::std::option::Option::Some(structured_data::Data::Sphere(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sphere(&mut self) -> &mut Sphere {
        if let ::std::option::Option::Some(structured_data::Data::Sphere(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(structured_data::Data::Sphere(Sphere::new()));
        }
        match self.data {
            ::std::option::Option::Some(structured_data::Data::Sphere(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sphere(&mut self) -> Sphere {
        if self.has_sphere() {
            match self.data.take() {
                ::std::option::Option::Some(structured_data::Data::Sphere(v)) => v,
                _ => panic!(),
            }
        } else {
            Sphere::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Polygon2>(
            "polygon2",
            StructuredData::has_polygon2,
            StructuredData::polygon2,
            StructuredData::mut_polygon2,
            StructuredData::set_polygon2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Graph>(
            "graph",
            StructuredData::has_graph,
            StructuredData::graph,
            StructuredData::mut_graph,
            StructuredData::set_graph,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Point2>(
            "point2",
            StructuredData::has_point2,
            StructuredData::point2,
            StructuredData::mut_point2,
            StructuredData::set_point2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Image2>(
            "image2",
            StructuredData::has_image2,
            StructuredData::image2,
            StructuredData::mut_image2,
            StructuredData::set_image2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Segment2>(
            "segment2",
            StructuredData::has_segment2,
            StructuredData::segment2,
            StructuredData::mut_segment2,
            StructuredData::set_segment2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Object3>(
            "object3",
            StructuredData::has_object3,
            StructuredData::object3,
            StructuredData::mut_object3,
            StructuredData::set_object3,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Object2>(
            "object2",
            StructuredData::has_object2,
            StructuredData::object2,
            StructuredData::mut_object2,
            StructuredData::set_object2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Sphere>(
            "sphere",
            StructuredData::has_sphere,
            StructuredData::sphere,
            StructuredData::mut_sphere,
            StructuredData::set_sphere,
        ));
        oneofs.push(structured_data::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StructuredData>(
            "StructuredData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StructuredData {
    const NAME: &'static str = "StructuredData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Polygon2(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Graph(is.read_message()?));
                },
                26 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Point2(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Image2(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Segment2(is.read_message()?));
                },
                50 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Object3(is.read_message()?));
                },
                58 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Object2(is.read_message()?));
                },
                66 => {
                    self.data = ::std::option::Option::Some(structured_data::Data::Sphere(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &structured_data::Data::Polygon2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Graph(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Point2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Image2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Segment2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Object3(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Object2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &structured_data::Data::Sphere(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &structured_data::Data::Polygon2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &structured_data::Data::Graph(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &structured_data::Data::Point2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &structured_data::Data::Image2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &structured_data::Data::Segment2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &structured_data::Data::Object3(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &structured_data::Data::Object2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &structured_data::Data::Sphere(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StructuredData {
        StructuredData::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StructuredData {
        static instance: StructuredData = StructuredData {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StructuredData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StructuredData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StructuredData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StructuredData`
pub mod structured_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.StructuredData.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.polygon2)
        Polygon2(super::super::math::Polygon2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.graph)
        Graph(super::super::math::Graph),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.point2)
        Point2(super::super::math::Point2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.image2)
        Image2(super::Image2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.segment2)
        Segment2(super::super::math::Segment2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.object3)
        Object3(super::Object3),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.object2)
        Object2(super::Object2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.StructuredData.sphere)
        Sphere(super::Sphere),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StructuredData as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Image2)
pub struct Image2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Image2.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:observation_tools.proto.Image2.mime_type)
    pub mime_type: ::std::string::String,
    // @@protoc_insertion_point(field:observation_tools.proto.Image2.pixel_to_world_transform)
    pub pixel_to_world_transform: ::protobuf::MessageField<super::math::Matrix3x3>,
    // @@protoc_insertion_point(field:observation_tools.proto.Image2.pixel_transform)
    pub pixel_transform: ::protobuf::MessageField<PerPixelTransform>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Image2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image2 {
    fn default() -> &'a Image2 {
        <Image2 as ::protobuf::Message>::default_instance()
    }
}

impl Image2 {
    pub fn new() -> Image2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Image2| { &m.data },
            |m: &mut Image2| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mime_type",
            |m: &Image2| { &m.mime_type },
            |m: &mut Image2| { &mut m.mime_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Matrix3x3>(
            "pixel_to_world_transform",
            |m: &Image2| { &m.pixel_to_world_transform },
            |m: &mut Image2| { &mut m.pixel_to_world_transform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PerPixelTransform>(
            "pixel_transform",
            |m: &Image2| { &m.pixel_transform },
            |m: &mut Image2| { &mut m.pixel_transform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Image2>(
            "Image2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Image2 {
    const NAME: &'static str = "Image2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.data = is.read_bytes()?;
                },
                42 => {
                    self.mime_type = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pixel_to_world_transform)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pixel_transform)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if !self.mime_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mime_type);
        }
        if let Some(v) = self.pixel_to_world_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pixel_transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if !self.mime_type.is_empty() {
            os.write_string(5, &self.mime_type)?;
        }
        if let Some(v) = self.pixel_to_world_transform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pixel_transform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image2 {
        Image2::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.mime_type.clear();
        self.pixel_to_world_transform.clear();
        self.pixel_transform.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image2 {
        static instance: Image2 = Image2 {
            data: ::std::vec::Vec::new(),
            mime_type: ::std::string::String::new(),
            pixel_to_world_transform: ::protobuf::MessageField::none(),
            pixel_transform: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Image2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Image2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Image2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.PerPixelTransform)
pub struct PerPixelTransform {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.PerPixelTransform.random_distinct_color)
    pub random_distinct_color: ::protobuf::MessageField<RandomDistinctColor>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.PerPixelTransform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PerPixelTransform {
    fn default() -> &'a PerPixelTransform {
        <PerPixelTransform as ::protobuf::Message>::default_instance()
    }
}

impl PerPixelTransform {
    pub fn new() -> PerPixelTransform {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RandomDistinctColor>(
            "random_distinct_color",
            |m: &PerPixelTransform| { &m.random_distinct_color },
            |m: &mut PerPixelTransform| { &mut m.random_distinct_color },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerPixelTransform>(
            "PerPixelTransform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PerPixelTransform {
    const NAME: &'static str = "PerPixelTransform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.random_distinct_color)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.random_distinct_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.random_distinct_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PerPixelTransform {
        PerPixelTransform::new()
    }

    fn clear(&mut self) {
        self.random_distinct_color.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PerPixelTransform {
        static instance: PerPixelTransform = PerPixelTransform {
            random_distinct_color: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PerPixelTransform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PerPixelTransform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PerPixelTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerPixelTransform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.RandomDistinctColor)
pub struct RandomDistinctColor {
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.RandomDistinctColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RandomDistinctColor {
    fn default() -> &'a RandomDistinctColor {
        <RandomDistinctColor as ::protobuf::Message>::default_instance()
    }
}

impl RandomDistinctColor {
    pub fn new() -> RandomDistinctColor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RandomDistinctColor>(
            "RandomDistinctColor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RandomDistinctColor {
    const NAME: &'static str = "RandomDistinctColor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RandomDistinctColor {
        RandomDistinctColor::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RandomDistinctColor {
        static instance: RandomDistinctColor = RandomDistinctColor {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RandomDistinctColor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RandomDistinctColor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RandomDistinctColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomDistinctColor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Object2)
pub struct Object2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Object2.geometry)
    pub geometry: ::protobuf::MessageField<Geometry2>,
    // @@protoc_insertion_point(field:observation_tools.proto.Object2.transforms)
    pub transforms: ::std::vec::Vec<super::math::Transform2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Object2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Object2 {
    fn default() -> &'a Object2 {
        <Object2 as ::protobuf::Message>::default_instance()
    }
}

impl Object2 {
    pub fn new() -> Object2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Geometry2>(
            "geometry",
            |m: &Object2| { &m.geometry },
            |m: &mut Object2| { &mut m.geometry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transforms",
            |m: &Object2| { &m.transforms },
            |m: &mut Object2| { &mut m.transforms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Object2>(
            "Object2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Object2 {
    const NAME: &'static str = "Object2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geometry)?;
                },
                18 => {
                    self.transforms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.transforms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.geometry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.transforms {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Object2 {
        Object2::new()
    }

    fn clear(&mut self) {
        self.geometry.clear();
        self.transforms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Object2 {
        static instance: Object2 = Object2 {
            geometry: ::protobuf::MessageField::none(),
            transforms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Object2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Object2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Object2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Geometry2)
pub struct Geometry2 {
    // message oneof groups
    pub data: ::std::option::Option<geometry2::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Geometry2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Geometry2 {
    fn default() -> &'a Geometry2 {
        <Geometry2 as ::protobuf::Message>::default_instance()
    }
}

impl Geometry2 {
    pub fn new() -> Geometry2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Point2 point2 = 1;

    pub fn point2(&self) -> &super::math::Point2 {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Point2(ref v)) => v,
            _ => <super::math::Point2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_point2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_point2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Point2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_point2(&mut self, v: super::math::Point2) {
        self.data = ::std::option::Option::Some(geometry2::Data::Point2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_point2(&mut self) -> &mut super::math::Point2 {
        if let ::std::option::Option::Some(geometry2::Data::Point2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry2::Data::Point2(super::math::Point2::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Point2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_point2(&mut self) -> super::math::Point2 {
        if self.has_point2() {
            match self.data.take() {
                ::std::option::Option::Some(geometry2::Data::Point2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Point2::new()
        }
    }

    // .observation_tools.proto.Polygon2 polygon2 = 2;

    pub fn polygon2(&self) -> &super::math::Polygon2 {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Polygon2(ref v)) => v,
            _ => <super::math::Polygon2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_polygon2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_polygon2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Polygon2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_polygon2(&mut self, v: super::math::Polygon2) {
        self.data = ::std::option::Option::Some(geometry2::Data::Polygon2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_polygon2(&mut self) -> &mut super::math::Polygon2 {
        if let ::std::option::Option::Some(geometry2::Data::Polygon2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry2::Data::Polygon2(super::math::Polygon2::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Polygon2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_polygon2(&mut self) -> super::math::Polygon2 {
        if self.has_polygon2() {
            match self.data.take() {
                ::std::option::Option::Some(geometry2::Data::Polygon2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Polygon2::new()
        }
    }

    // .observation_tools.proto.Segment2 segment2 = 3;

    pub fn segment2(&self) -> &super::math::Segment2 {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Segment2(ref v)) => v,
            _ => <super::math::Segment2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_segment2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_segment2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Segment2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_segment2(&mut self, v: super::math::Segment2) {
        self.data = ::std::option::Option::Some(geometry2::Data::Segment2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_segment2(&mut self) -> &mut super::math::Segment2 {
        if let ::std::option::Option::Some(geometry2::Data::Segment2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry2::Data::Segment2(super::math::Segment2::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Segment2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_segment2(&mut self) -> super::math::Segment2 {
        if self.has_segment2() {
            match self.data.take() {
                ::std::option::Option::Some(geometry2::Data::Segment2(v)) => v,
                _ => panic!(),
            }
        } else {
            super::math::Segment2::new()
        }
    }

    // .observation_tools.proto.Image2 image2 = 4;

    pub fn image2(&self) -> &Image2 {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Image2(ref v)) => v,
            _ => <Image2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_image2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_image2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Image2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image2(&mut self, v: Image2) {
        self.data = ::std::option::Option::Some(geometry2::Data::Image2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image2(&mut self) -> &mut Image2 {
        if let ::std::option::Option::Some(geometry2::Data::Image2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry2::Data::Image2(Image2::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry2::Data::Image2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image2(&mut self) -> Image2 {
        if self.has_image2() {
            match self.data.take() {
                ::std::option::Option::Some(geometry2::Data::Image2(v)) => v,
                _ => panic!(),
            }
        } else {
            Image2::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Point2>(
            "point2",
            Geometry2::has_point2,
            Geometry2::point2,
            Geometry2::mut_point2,
            Geometry2::set_point2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Polygon2>(
            "polygon2",
            Geometry2::has_polygon2,
            Geometry2::polygon2,
            Geometry2::mut_polygon2,
            Geometry2::set_polygon2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::math::Segment2>(
            "segment2",
            Geometry2::has_segment2,
            Geometry2::segment2,
            Geometry2::mut_segment2,
            Geometry2::set_segment2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Image2>(
            "image2",
            Geometry2::has_image2,
            Geometry2::image2,
            Geometry2::mut_image2,
            Geometry2::set_image2,
        ));
        oneofs.push(geometry2::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Geometry2>(
            "Geometry2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Geometry2 {
    const NAME: &'static str = "Geometry2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(geometry2::Data::Point2(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(geometry2::Data::Polygon2(is.read_message()?));
                },
                26 => {
                    self.data = ::std::option::Option::Some(geometry2::Data::Segment2(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(geometry2::Data::Image2(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &geometry2::Data::Point2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &geometry2::Data::Polygon2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &geometry2::Data::Segment2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &geometry2::Data::Image2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &geometry2::Data::Point2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &geometry2::Data::Polygon2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &geometry2::Data::Segment2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &geometry2::Data::Image2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Geometry2 {
        Geometry2::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Geometry2 {
        static instance: Geometry2 = Geometry2 {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Geometry2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Geometry2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Geometry2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geometry2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Geometry2`
pub mod geometry2 {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.Geometry2.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry2.point2)
        Point2(super::super::math::Point2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry2.polygon2)
        Polygon2(super::super::math::Polygon2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry2.segment2)
        Segment2(super::super::math::Segment2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry2.image2)
        Image2(super::Image2),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Geometry2 as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Object3)
pub struct Object3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Object3.geometry)
    pub geometry: ::protobuf::MessageField<Geometry3>,
    // @@protoc_insertion_point(field:observation_tools.proto.Object3.transforms)
    pub transforms: ::std::vec::Vec<super::math::Transform3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Object3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Object3 {
    fn default() -> &'a Object3 {
        <Object3 as ::protobuf::Message>::default_instance()
    }
}

impl Object3 {
    pub fn new() -> Object3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Geometry3>(
            "geometry",
            |m: &Object3| { &m.geometry },
            |m: &mut Object3| { &mut m.geometry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transforms",
            |m: &Object3| { &m.transforms },
            |m: &mut Object3| { &mut m.transforms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Object3>(
            "Object3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Object3 {
    const NAME: &'static str = "Object3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geometry)?;
                },
                26 => {
                    self.transforms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.transforms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.geometry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.transforms {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Object3 {
        Object3::new()
    }

    fn clear(&mut self) {
        self.geometry.clear();
        self.transforms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Object3 {
        static instance: Object3 = Object3 {
            geometry: ::protobuf::MessageField::none(),
            transforms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Object3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Object3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Object3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Geometry3)
pub struct Geometry3 {
    // message oneof groups
    pub data: ::std::option::Option<geometry3::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Geometry3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Geometry3 {
    fn default() -> &'a Geometry3 {
        <Geometry3 as ::protobuf::Message>::default_instance()
    }
}

impl Geometry3 {
    pub fn new() -> Geometry3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Sphere sphere = 1;

    pub fn sphere(&self) -> &Sphere {
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Sphere(ref v)) => v,
            _ => <Sphere as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sphere(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sphere(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Sphere(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sphere(&mut self, v: Sphere) {
        self.data = ::std::option::Option::Some(geometry3::Data::Sphere(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sphere(&mut self) -> &mut Sphere {
        if let ::std::option::Option::Some(geometry3::Data::Sphere(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry3::Data::Sphere(Sphere::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Sphere(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sphere(&mut self) -> Sphere {
        if self.has_sphere() {
            match self.data.take() {
                ::std::option::Option::Some(geometry3::Data::Sphere(v)) => v,
                _ => panic!(),
            }
        } else {
            Sphere::new()
        }
    }

    // .observation_tools.proto.Mesh mesh = 2;

    pub fn mesh(&self) -> &Mesh {
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Mesh(ref v)) => v,
            _ => <Mesh as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mesh(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mesh(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Mesh(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mesh(&mut self, v: Mesh) {
        self.data = ::std::option::Option::Some(geometry3::Data::Mesh(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mesh(&mut self) -> &mut Mesh {
        if let ::std::option::Option::Some(geometry3::Data::Mesh(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(geometry3::Data::Mesh(Mesh::new()));
        }
        match self.data {
            ::std::option::Option::Some(geometry3::Data::Mesh(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mesh(&mut self) -> Mesh {
        if self.has_mesh() {
            match self.data.take() {
                ::std::option::Option::Some(geometry3::Data::Mesh(v)) => v,
                _ => panic!(),
            }
        } else {
            Mesh::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Sphere>(
            "sphere",
            Geometry3::has_sphere,
            Geometry3::sphere,
            Geometry3::mut_sphere,
            Geometry3::set_sphere,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Mesh>(
            "mesh",
            Geometry3::has_mesh,
            Geometry3::mesh,
            Geometry3::mut_mesh,
            Geometry3::set_mesh,
        ));
        oneofs.push(geometry3::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Geometry3>(
            "Geometry3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Geometry3 {
    const NAME: &'static str = "Geometry3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(geometry3::Data::Sphere(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(geometry3::Data::Mesh(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &geometry3::Data::Sphere(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &geometry3::Data::Mesh(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &geometry3::Data::Sphere(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &geometry3::Data::Mesh(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Geometry3 {
        Geometry3::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Geometry3 {
        static instance: Geometry3 = Geometry3 {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Geometry3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Geometry3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Geometry3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geometry3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Geometry3`
pub mod geometry3 {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.Geometry3.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry3.sphere)
        Sphere(super::Sphere),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Geometry3.mesh)
        Mesh(super::Mesh),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Geometry3 as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Sphere)
pub struct Sphere {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Sphere.radius)
    pub radius: ::protobuf::MessageField<super::math::Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Sphere.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sphere {
    fn default() -> &'a Sphere {
        <Sphere as ::protobuf::Message>::default_instance()
    }
}

impl Sphere {
    pub fn new() -> Sphere {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Number>(
            "radius",
            |m: &Sphere| { &m.radius },
            |m: &mut Sphere| { &mut m.radius },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sphere>(
            "Sphere",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sphere {
    const NAME: &'static str = "Sphere";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radius)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radius.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sphere {
        Sphere::new()
    }

    fn clear(&mut self) {
        self.radius.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sphere {
        static instance: Sphere = Sphere {
            radius: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sphere {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sphere").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sphere {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sphere {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Mesh)
pub struct Mesh {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Mesh.vertices)
    pub vertices: ::std::vec::Vec<Vertex>,
    // @@protoc_insertion_point(field:observation_tools.proto.Mesh.indices)
    pub indices: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Mesh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mesh {
    fn default() -> &'a Mesh {
        <Mesh as ::protobuf::Message>::default_instance()
    }
}

impl Mesh {
    pub fn new() -> Mesh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vertices",
            |m: &Mesh| { &m.vertices },
            |m: &mut Mesh| { &mut m.vertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "indices",
            |m: &Mesh| { &m.indices },
            |m: &mut Mesh| { &mut m.indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mesh>(
            "Mesh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Mesh {
    const NAME: &'static str = "Mesh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vertices.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.indices)?;
                },
                16 => {
                    self.indices.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.vertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.indices {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.vertices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.indices {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mesh {
        Mesh::new()
    }

    fn clear(&mut self) {
        self.vertices.clear();
        self.indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mesh {
        static instance: Mesh = Mesh {
            vertices: ::std::vec::Vec::new(),
            indices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Mesh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mesh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mesh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Vertex)
pub struct Vertex {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Vertex.position)
    pub position: ::protobuf::MessageField<super::math::Point3>,
    // @@protoc_insertion_point(field:observation_tools.proto.Vertex.normal)
    pub normal: ::protobuf::MessageField<super::math::Vector3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Vertex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vertex {
    fn default() -> &'a Vertex {
        <Vertex as ::protobuf::Message>::default_instance()
    }
}

impl Vertex {
    pub fn new() -> Vertex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Point3>(
            "position",
            |m: &Vertex| { &m.position },
            |m: &mut Vertex| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::math::Vector3>(
            "normal",
            |m: &Vertex| { &m.normal },
            |m: &mut Vertex| { &mut m.normal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vertex>(
            "Vertex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vertex {
    const NAME: &'static str = "Vertex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vertex {
        Vertex::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.normal.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vertex {
        static instance: Vertex = Vertex {
            position: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vertex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vertex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vertex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vertex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.ArtifactUpdate)
pub struct ArtifactUpdate {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactUpdate.field_data)
    pub field_data: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:observation_tools.proto.ArtifactUpdate.field)
    pub field: ::protobuf::MessageField<::protobuf::well_known_types::field_mask::FieldMask>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.ArtifactUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactUpdate {
    fn default() -> &'a ArtifactUpdate {
        <ArtifactUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactUpdate {
    pub fn new() -> ArtifactUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "field_data",
            |m: &ArtifactUpdate| { &m.field_data },
            |m: &mut ArtifactUpdate| { &mut m.field_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::field_mask::FieldMask>(
            "field",
            |m: &ArtifactUpdate| { &m.field },
            |m: &mut ArtifactUpdate| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactUpdate>(
            "ArtifactUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactUpdate {
    const NAME: &'static str = "ArtifactUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.field_data)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.field)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.field_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.field.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.field_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.field.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactUpdate {
        ArtifactUpdate::new()
    }

    fn clear(&mut self) {
        self.field_data.clear();
        self.field.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactUpdate {
        static instance: ArtifactUpdate = ArtifactUpdate {
            field_data: ::protobuf::MessageField::none(),
            field: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ArtifactUpdate`
pub mod artifact_update {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:observation_tools.proto.ArtifactUpdate.Operation)
    pub enum Operation {
        // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactUpdate.Operation.OPERATION_UNKNOWN)
        OPERATION_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactUpdate.Operation.OPERATION_CREATE)
        OPERATION_CREATE = 1,
    }

    impl ::protobuf::Enum for Operation {
        const NAME: &'static str = "Operation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Operation> {
            match value {
                0 => ::std::option::Option::Some(Operation::OPERATION_UNKNOWN),
                1 => ::std::option::Option::Some(Operation::OPERATION_CREATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Operation] = &[
            Operation::OPERATION_UNKNOWN,
            Operation::OPERATION_CREATE,
        ];
    }

    impl ::protobuf::EnumFull for Operation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ArtifactUpdate.Operation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Operation {
        fn default() -> Self {
            Operation::OPERATION_UNKNOWN
        }
    }

    impl Operation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Operation>("ArtifactUpdate.Operation")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:observation_tools.proto.ArtifactType)
pub enum ArtifactType {
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_UNKNOWN)
    ARTIFACT_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_GENERIC)
    ARTIFACT_TYPE_GENERIC = 1,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_2D_GROUP)
    ARTIFACT_TYPE_2D_GROUP = 2,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_3D_GROUP)
    ARTIFACT_TYPE_3D_GROUP = 3,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_2D_IN_3D_GROUP)
    ARTIFACT_TYPE_2D_IN_3D_GROUP = 4,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_RUN_STAGE)
    ARTIFACT_TYPE_RUN_STAGE = 5,
    // @@protoc_insertion_point(enum_value:observation_tools.proto.ArtifactType.ARTIFACT_TYPE_ROOT_GROUP)
    ARTIFACT_TYPE_ROOT_GROUP = 6,
}

impl ::protobuf::Enum for ArtifactType {
    const NAME: &'static str = "ArtifactType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtifactType> {
        match value {
            0 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_GENERIC),
            2 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_2D_GROUP),
            3 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_3D_GROUP),
            4 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_2D_IN_3D_GROUP),
            5 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_RUN_STAGE),
            6 => ::std::option::Option::Some(ArtifactType::ARTIFACT_TYPE_ROOT_GROUP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ArtifactType] = &[
        ArtifactType::ARTIFACT_TYPE_UNKNOWN,
        ArtifactType::ARTIFACT_TYPE_GENERIC,
        ArtifactType::ARTIFACT_TYPE_2D_GROUP,
        ArtifactType::ARTIFACT_TYPE_3D_GROUP,
        ArtifactType::ARTIFACT_TYPE_2D_IN_3D_GROUP,
        ArtifactType::ARTIFACT_TYPE_RUN_STAGE,
        ArtifactType::ARTIFACT_TYPE_ROOT_GROUP,
    ];
}

impl ::protobuf::EnumFull for ArtifactType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ArtifactType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ArtifactType {
    fn default() -> Self {
        ArtifactType::ARTIFACT_TYPE_UNKNOWN
    }
}

impl ArtifactType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArtifactType>("ArtifactType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20src/api/artifacts/artifact.proto\x12\x17observation_tools.proto\
    \x1a\x1csrc/api/artifacts/uuid.proto\x1a\x1csrc/api/artifacts/math.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19google/protobuf/any.proto\
    \x1a\x20google/protobuf/field_mask.proto\"?\n\nArtifactId\x121\n\x04uuid\
    \x18\x01\x20\x01(\x0b2\x1d.observation_tools.proto.UuidR\x04uuid\"\xbb\
    \x04\n\x0cArtifactData\x12Q\n\x12ancestor_group_ids\x18\x06\x20\x03(\x0b\
    2#.observation_tools.proto.ArtifactIdR\x10ancestorGroupIds\x12R\n\ruser_\
    metadata\x18\x07\x20\x01(\x0b2-.observation_tools.proto.ArtifactUserMeta\
    dataR\x0cuserMetadata\x12J\n\rartifact_type\x18\x08\x20\x01(\x0e2%.obser\
    vation_tools.proto.ArtifactTypeR\x0cartifactType\x12M\n\x0erun_stage_dat\
    a\x18\t\x20\x01(\x0b2%.observation_tools.proto.RunStageDataH\0R\x0crunSt\
    ageData\x12I\n\x0cmap_2d_to_3d\x18\n\x20\x01(\x0b2&.observation_tools.pr\
    oto.Map2dTo3dDataH\0R\tmap2dTo3d\x12=\n\x08group_3d\x18\x0b\x20\x01(\x0b\
    2\x20.observation_tools.proto.Group3dH\0R\x07group3d\x12L\n\x14client_cr\
    eation_time\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x12clie\
    ntCreationTimeB\x0b\n\ttype_dataJ\x04\x08\x01\x10\x05\"\xc0\x01\n\x14Art\
    ifactUserMetadata\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12W\n\
    \x08metadata\x18\x02\x20\x03(\x0b2;.observation_tools.proto.ArtifactUser\
    Metadata.MetadataEntryR\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\"h\n\x0cRunStageData\x12X\n\x16previous_run_stage_ids\
    \x18\x01\x20\x03(\x0b2#.observation_tools.proto.ArtifactIdR\x13previousR\
    unStageIds\"b\n\rMap2dTo3dData\x12K\n\x0fto_3d_transform\x18\x02\x20\x01\
    (\x0b2#.observation_tools.proto.Transform3R\rto3dTransformJ\x04\x08\x01\
    \x10\x02\"[\n\x07Group3d\x12J\n\x0ebase_transform\x18\x02\x20\x01(\x0b2#\
    .observation_tools.proto.Transform3R\rbaseTransformJ\x04\x08\x01\x10\x02\
    \"\x8f\x04\n\x0eStructuredData\x12C\n\x08polygon2\x18\x01\x20\x01(\x0b2!\
    .observation_tools.proto.Polygon2H\0R\x08polygon2B\x02\x18\x01\x126\n\
    \x05graph\x18\x02\x20\x01(\x0b2\x1e.observation_tools.proto.GraphH\0R\
    \x05graph\x12=\n\x06point2\x18\x03\x20\x01(\x0b2\x1f.observation_tools.p\
    roto.Point2H\0R\x06point2B\x02\x18\x01\x129\n\x06image2\x18\x04\x20\x01(\
    \x0b2\x1f.observation_tools.proto.Image2H\0R\x06image2\x12C\n\x08segment\
    2\x18\x05\x20\x01(\x0b2!.observation_tools.proto.Segment2H\0R\x08segment\
    2B\x02\x18\x01\x12<\n\x07object3\x18\x06\x20\x01(\x0b2\x20.observation_t\
    ools.proto.Object3H\0R\x07object3\x12<\n\x07object2\x18\x07\x20\x01(\x0b\
    2\x20.observation_tools.proto.Object2H\0R\x07object2\x12=\n\x06sphere\
    \x18\x08\x20\x01(\x0b2\x1f.observation_tools.proto.SphereH\0R\x06sphereB\
    \x02\x18\x01B\x06\n\x04data\"\xf5\x01\n\x06Image2\x12\x12\n\x04data\x18\
    \x04\x20\x01(\x0cR\x04data\x12\x1b\n\tmime_type\x18\x05\x20\x01(\tR\x08m\
    imeType\x12_\n\x18pixel_to_world_transform\x18\x02\x20\x01(\x0b2\".obser\
    vation_tools.proto.Matrix3x3R\x15pixelToWorldTransformB\x02\x18\x01\x12S\
    \n\x0fpixel_transform\x18\x03\x20\x01(\x0b2*.observation_tools.proto.Per\
    PixelTransformR\x0epixelTransformJ\x04\x08\x01\x10\x02\"u\n\x11PerPixelT\
    ransform\x12`\n\x15random_distinct_color\x18\x01\x20\x01(\x0b2,.observat\
    ion_tools.proto.RandomDistinctColorR\x13randomDistinctColor\"\x15\n\x13R\
    andomDistinctColor\"\x8e\x01\n\x07Object2\x12>\n\x08geometry\x18\x01\x20\
    \x01(\x0b2\".observation_tools.proto.Geometry2R\x08geometry\x12C\n\ntran\
    sforms\x18\x02\x20\x03(\x0b2#.observation_tools.proto.Transform2R\ntrans\
    forms\"\x8b\x02\n\tGeometry2\x129\n\x06point2\x18\x01\x20\x01(\x0b2\x1f.\
    observation_tools.proto.Point2H\0R\x06point2\x12?\n\x08polygon2\x18\x02\
    \x20\x01(\x0b2!.observation_tools.proto.Polygon2H\0R\x08polygon2\x12?\n\
    \x08segment2\x18\x03\x20\x01(\x0b2!.observation_tools.proto.Segment2H\0R\
    \x08segment2\x129\n\x06image2\x18\x04\x20\x01(\x0b2\x1f.observation_tool\
    s.proto.Image2H\0R\x06image2B\x06\n\x04data\"\x94\x01\n\x07Object3\x12>\
    \n\x08geometry\x18\x01\x20\x01(\x0b2\".observation_tools.proto.Geometry3\
    R\x08geometry\x12C\n\ntransforms\x18\x03\x20\x03(\x0b2#.observation_tool\
    s.proto.Transform3R\ntransformsJ\x04\x08\x02\x10\x03\"\x83\x01\n\tGeomet\
    ry3\x129\n\x06sphere\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.S\
    phereH\0R\x06sphere\x123\n\x04mesh\x18\x02\x20\x01(\x0b2\x1d.observation\
    _tools.proto.MeshH\0R\x04meshB\x06\n\x04data\"A\n\x06Sphere\x127\n\x06ra\
    dius\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x06radius\
    \"]\n\x04Mesh\x12;\n\x08vertices\x18\x01\x20\x03(\x0b2\x1f.observation_t\
    ools.proto.VertexR\x08vertices\x12\x18\n\x07indices\x18\x02\x20\x03(\rR\
    \x07indices\"\x7f\n\x06Vertex\x12;\n\x08position\x18\x01\x20\x01(\x0b2\
    \x1f.observation_tools.proto.Point3R\x08position\x128\n\x06normal\x18\
    \x02\x20\x01(\x0b2\x20.observation_tools.proto.Vector3R\x06normal\"\xb1\
    \x01\n\x0eArtifactUpdate\x123\n\nfield_data\x18\x01\x20\x01(\x0b2\x14.go\
    ogle.protobuf.AnyR\tfieldData\x120\n\x05field\x18\x02\x20\x01(\x0b2\x1a.\
    google.protobuf.FieldMaskR\x05field\"8\n\tOperation\x12\x15\n\x11OPERATI\
    ON_UNKNOWN\x10\0\x12\x14\n\x10OPERATION_CREATE\x10\x01*\xd9\x01\n\x0cArt\
    ifactType\x12\x19\n\x15ARTIFACT_TYPE_UNKNOWN\x10\0\x12\x19\n\x15ARTIFACT\
    _TYPE_GENERIC\x10\x01\x12\x1a\n\x16ARTIFACT_TYPE_2D_GROUP\x10\x02\x12\
    \x1a\n\x16ARTIFACT_TYPE_3D_GROUP\x10\x03\x12\x20\n\x1cARTIFACT_TYPE_2D_I\
    N_3D_GROUP\x10\x04\x12\x1b\n\x17ARTIFACT_TYPE_RUN_STAGE\x10\x05\x12\x1c\
    \n\x18ARTIFACT_TYPE_ROOT_GROUP\x10\x06B\x1b\n\x17tools.observation.proto\
    P\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::uuid::file_descriptor().clone());
            deps.push(super::math::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::field_mask::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(ArtifactId::generated_message_descriptor_data());
            messages.push(ArtifactData::generated_message_descriptor_data());
            messages.push(ArtifactUserMetadata::generated_message_descriptor_data());
            messages.push(RunStageData::generated_message_descriptor_data());
            messages.push(Map2dTo3dData::generated_message_descriptor_data());
            messages.push(Group3d::generated_message_descriptor_data());
            messages.push(StructuredData::generated_message_descriptor_data());
            messages.push(Image2::generated_message_descriptor_data());
            messages.push(PerPixelTransform::generated_message_descriptor_data());
            messages.push(RandomDistinctColor::generated_message_descriptor_data());
            messages.push(Object2::generated_message_descriptor_data());
            messages.push(Geometry2::generated_message_descriptor_data());
            messages.push(Object3::generated_message_descriptor_data());
            messages.push(Geometry3::generated_message_descriptor_data());
            messages.push(Sphere::generated_message_descriptor_data());
            messages.push(Mesh::generated_message_descriptor_data());
            messages.push(Vertex::generated_message_descriptor_data());
            messages.push(ArtifactUpdate::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ArtifactType::generated_enum_descriptor_data());
            enums.push(artifact_update::Operation::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
