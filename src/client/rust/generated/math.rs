// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/proto/math.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Number)
pub struct Number {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Number.d)
    pub d: f64,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Number.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Number {
    fn default() -> &'a Number {
        <Number as ::protobuf::Message>::default_instance()
    }
}

impl Number {
    pub fn new() -> Number {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "d",
            |m: &Number| { &m.d },
            |m: &mut Number| { &mut m.d },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Number>(
            "Number",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Number {
    const NAME: &'static str = "Number";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.d = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.d != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.d != 0. {
            os.write_double(1, self.d)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Number {
        Number::new()
    }

    fn clear(&mut self) {
        self.d = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Number {
        static instance: Number = Number {
            d: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Number {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Number").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Number {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Number {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Point2)
pub struct Point2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Point2.x)
    pub x: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Point2.y)
    pub y: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Point2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point2 {
    fn default() -> &'a Point2 {
        <Point2 as ::protobuf::Message>::default_instance()
    }
}

impl Point2 {
    pub fn new() -> Point2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "x",
            |m: &Point2| { &m.x },
            |m: &mut Point2| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "y",
            |m: &Point2| { &m.y },
            |m: &mut Point2| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point2>(
            "Point2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point2 {
    const NAME: &'static str = "Point2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.x)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.y)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point2 {
        Point2::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point2 {
        static instance: Point2 = Point2 {
            x: ::protobuf::MessageField::none(),
            y: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Segment2)
pub struct Segment2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Segment2.start)
    pub start: ::protobuf::MessageField<Point2>,
    // @@protoc_insertion_point(field:observation_tools.proto.Segment2.end)
    pub end: ::protobuf::MessageField<Point2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Segment2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Segment2 {
    fn default() -> &'a Segment2 {
        <Segment2 as ::protobuf::Message>::default_instance()
    }
}

impl Segment2 {
    pub fn new() -> Segment2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point2>(
            "start",
            |m: &Segment2| { &m.start },
            |m: &mut Segment2| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point2>(
            "end",
            |m: &Segment2| { &m.end },
            |m: &mut Segment2| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Segment2>(
            "Segment2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Segment2 {
    const NAME: &'static str = "Segment2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Segment2 {
        Segment2::new()
    }

    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Segment2 {
        static instance: Segment2 = Segment2 {
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Segment2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Segment2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Segment2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Segment2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Point3)
pub struct Point3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Point3.x)
    pub x: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Point3.y)
    pub y: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Point3.z)
    pub z: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Point3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point3 {
    fn default() -> &'a Point3 {
        <Point3 as ::protobuf::Message>::default_instance()
    }
}

impl Point3 {
    pub fn new() -> Point3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "x",
            |m: &Point3| { &m.x },
            |m: &mut Point3| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "y",
            |m: &Point3| { &m.y },
            |m: &mut Point3| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "z",
            |m: &Point3| { &m.z },
            |m: &mut Point3| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point3>(
            "Point3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point3 {
    const NAME: &'static str = "Point3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.x)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.y)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.z)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.z.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point3 {
        Point3::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point3 {
        static instance: Point3 = Point3 {
            x: ::protobuf::MessageField::none(),
            y: ::protobuf::MessageField::none(),
            z: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Vector2)
pub struct Vector2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Vector2.x)
    pub x: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Vector2.y)
    pub y: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Vector2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vector2 {
    fn default() -> &'a Vector2 {
        <Vector2 as ::protobuf::Message>::default_instance()
    }
}

impl Vector2 {
    pub fn new() -> Vector2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "x",
            |m: &Vector2| { &m.x },
            |m: &mut Vector2| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "y",
            |m: &Vector2| { &m.y },
            |m: &mut Vector2| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vector2>(
            "Vector2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vector2 {
    const NAME: &'static str = "Vector2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.x)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.y)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vector2 {
        Vector2::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vector2 {
        static instance: Vector2 = Vector2 {
            x: ::protobuf::MessageField::none(),
            y: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vector2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vector2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vector2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Vector3)
pub struct Vector3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Vector3.x)
    pub x: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Vector3.y)
    pub y: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Vector3.z)
    pub z: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Vector3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vector3 {
    fn default() -> &'a Vector3 {
        <Vector3 as ::protobuf::Message>::default_instance()
    }
}

impl Vector3 {
    pub fn new() -> Vector3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "x",
            |m: &Vector3| { &m.x },
            |m: &mut Vector3| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "y",
            |m: &Vector3| { &m.y },
            |m: &mut Vector3| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "z",
            |m: &Vector3| { &m.z },
            |m: &mut Vector3| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vector3>(
            "Vector3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vector3 {
    const NAME: &'static str = "Vector3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.x)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.y)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.z)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.z.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vector3 {
        Vector3::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vector3 {
        static instance: Vector3 = Vector3 {
            x: ::protobuf::MessageField::none(),
            y: ::protobuf::MessageField::none(),
            z: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vector3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vector3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vector3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.PolygonEdge2)
pub struct PolygonEdge2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.PolygonEdge2.vertex)
    pub vertex: ::protobuf::MessageField<Point2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.PolygonEdge2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PolygonEdge2 {
    fn default() -> &'a PolygonEdge2 {
        <PolygonEdge2 as ::protobuf::Message>::default_instance()
    }
}

impl PolygonEdge2 {
    pub fn new() -> PolygonEdge2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point2>(
            "vertex",
            |m: &PolygonEdge2| { &m.vertex },
            |m: &mut PolygonEdge2| { &mut m.vertex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PolygonEdge2>(
            "PolygonEdge2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PolygonEdge2 {
    const NAME: &'static str = "PolygonEdge2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vertex)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vertex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vertex.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PolygonEdge2 {
        PolygonEdge2::new()
    }

    fn clear(&mut self) {
        self.vertex.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PolygonEdge2 {
        static instance: PolygonEdge2 = PolygonEdge2 {
            vertex: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PolygonEdge2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PolygonEdge2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PolygonEdge2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolygonEdge2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Polygon2)
pub struct Polygon2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Polygon2.edges)
    pub edges: ::std::vec::Vec<PolygonEdge2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Polygon2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Polygon2 {
    fn default() -> &'a Polygon2 {
        <Polygon2 as ::protobuf::Message>::default_instance()
    }
}

impl Polygon2 {
    pub fn new() -> Polygon2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &Polygon2| { &m.edges },
            |m: &mut Polygon2| { &mut m.edges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Polygon2>(
            "Polygon2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Polygon2 {
    const NAME: &'static str = "Polygon2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.edges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.edges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Polygon2 {
        Polygon2::new()
    }

    fn clear(&mut self) {
        self.edges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Polygon2 {
        static instance: Polygon2 = Polygon2 {
            edges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Polygon2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Polygon2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Polygon2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Polygon2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Rect2)
pub struct Rect2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Rect2.size)
    pub size: ::protobuf::MessageField<Vector2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Rect2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rect2 {
    fn default() -> &'a Rect2 {
        <Rect2 as ::protobuf::Message>::default_instance()
    }
}

impl Rect2 {
    pub fn new() -> Rect2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Vector2>(
            "size",
            |m: &Rect2| { &m.size },
            |m: &mut Rect2| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rect2>(
            "Rect2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rect2 {
    const NAME: &'static str = "Rect2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.size)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rect2 {
        Rect2::new()
    }

    fn clear(&mut self) {
        self.size.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rect2 {
        static instance: Rect2 = Rect2 {
            size: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rect2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rect2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rect2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rect2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.PolygonEdge3)
pub struct PolygonEdge3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.PolygonEdge3.vertex)
    pub vertex: ::protobuf::MessageField<Point3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.PolygonEdge3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PolygonEdge3 {
    fn default() -> &'a PolygonEdge3 {
        <PolygonEdge3 as ::protobuf::Message>::default_instance()
    }
}

impl PolygonEdge3 {
    pub fn new() -> PolygonEdge3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point3>(
            "vertex",
            |m: &PolygonEdge3| { &m.vertex },
            |m: &mut PolygonEdge3| { &mut m.vertex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PolygonEdge3>(
            "PolygonEdge3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PolygonEdge3 {
    const NAME: &'static str = "PolygonEdge3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vertex)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vertex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vertex.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PolygonEdge3 {
        PolygonEdge3::new()
    }

    fn clear(&mut self) {
        self.vertex.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PolygonEdge3 {
        static instance: PolygonEdge3 = PolygonEdge3 {
            vertex: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PolygonEdge3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PolygonEdge3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PolygonEdge3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolygonEdge3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Polygon3)
pub struct Polygon3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Polygon3.edges)
    pub edges: ::std::vec::Vec<PolygonEdge3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Polygon3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Polygon3 {
    fn default() -> &'a Polygon3 {
        <Polygon3 as ::protobuf::Message>::default_instance()
    }
}

impl Polygon3 {
    pub fn new() -> Polygon3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &Polygon3| { &m.edges },
            |m: &mut Polygon3| { &mut m.edges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Polygon3>(
            "Polygon3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Polygon3 {
    const NAME: &'static str = "Polygon3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.edges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.edges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Polygon3 {
        Polygon3::new()
    }

    fn clear(&mut self) {
        self.edges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Polygon3 {
        static instance: Polygon3 = Polygon3 {
            edges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Polygon3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Polygon3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Polygon3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Polygon3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Graph)
pub struct Graph {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Graph.nodes)
    pub nodes: ::std::collections::HashMap<::std::string::String, GraphNode>,
    // @@protoc_insertion_point(field:observation_tools.proto.Graph.edges)
    pub edges: ::std::collections::HashMap<::std::string::String, GraphEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Graph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Graph {
    fn default() -> &'a Graph {
        <Graph as ::protobuf::Message>::default_instance()
    }
}

impl Graph {
    pub fn new() -> Graph {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "nodes",
            |m: &Graph| { &m.nodes },
            |m: &mut Graph| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "edges",
            |m: &Graph| { &m.edges },
            |m: &mut Graph| { &mut m.edges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Graph>(
            "Graph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Graph {
    const NAME: &'static str = "Graph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.nodes.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.edges.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.nodes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.edges {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.nodes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.edges {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Graph {
        Graph::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.edges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Graph {
        static instance: ::protobuf::rt::Lazy<Graph> = ::protobuf::rt::Lazy::new();
        instance.get(Graph::new)
    }
}

impl ::protobuf::MessageFull for Graph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Graph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Graph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Graph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.GraphNode)
pub struct GraphNode {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.GraphNode.position)
    pub position: ::protobuf::MessageField<Point3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.GraphNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GraphNode {
    fn default() -> &'a GraphNode {
        <GraphNode as ::protobuf::Message>::default_instance()
    }
}

impl GraphNode {
    pub fn new() -> GraphNode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point3>(
            "position",
            |m: &GraphNode| { &m.position },
            |m: &mut GraphNode| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphNode>(
            "GraphNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GraphNode {
    const NAME: &'static str = "GraphNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GraphNode {
        GraphNode::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GraphNode {
        static instance: GraphNode = GraphNode {
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GraphNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GraphNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GraphNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.GraphEdge)
pub struct GraphEdge {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.GraphEdge.start_node_id)
    pub start_node_id: ::std::string::String,
    // @@protoc_insertion_point(field:observation_tools.proto.GraphEdge.end_node_id)
    pub end_node_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.GraphEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GraphEdge {
    fn default() -> &'a GraphEdge {
        <GraphEdge as ::protobuf::Message>::default_instance()
    }
}

impl GraphEdge {
    pub fn new() -> GraphEdge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_node_id",
            |m: &GraphEdge| { &m.start_node_id },
            |m: &mut GraphEdge| { &mut m.start_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_node_id",
            |m: &GraphEdge| { &m.end_node_id },
            |m: &mut GraphEdge| { &mut m.end_node_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphEdge>(
            "GraphEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GraphEdge {
    const NAME: &'static str = "GraphEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.start_node_id = is.read_string()?;
                },
                18 => {
                    self.end_node_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.start_node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.start_node_id);
        }
        if !self.end_node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.end_node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.start_node_id.is_empty() {
            os.write_string(1, &self.start_node_id)?;
        }
        if !self.end_node_id.is_empty() {
            os.write_string(2, &self.end_node_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GraphEdge {
        GraphEdge::new()
    }

    fn clear(&mut self) {
        self.start_node_id.clear();
        self.end_node_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GraphEdge {
        static instance: GraphEdge = GraphEdge {
            start_node_id: ::std::string::String::new(),
            end_node_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GraphEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GraphEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GraphEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Matrix3x3)
pub struct Matrix3x3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m0_0)
    pub m0_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m0_1)
    pub m0_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m0_2)
    pub m0_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m1_0)
    pub m1_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m1_1)
    pub m1_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m1_2)
    pub m1_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m2_0)
    pub m2_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m2_1)
    pub m2_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix3x3.m2_2)
    pub m2_2: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Matrix3x3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Matrix3x3 {
    fn default() -> &'a Matrix3x3 {
        <Matrix3x3 as ::protobuf::Message>::default_instance()
    }
}

impl Matrix3x3 {
    pub fn new() -> Matrix3x3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_0",
            |m: &Matrix3x3| { &m.m0_0 },
            |m: &mut Matrix3x3| { &mut m.m0_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_1",
            |m: &Matrix3x3| { &m.m0_1 },
            |m: &mut Matrix3x3| { &mut m.m0_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_2",
            |m: &Matrix3x3| { &m.m0_2 },
            |m: &mut Matrix3x3| { &mut m.m0_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_0",
            |m: &Matrix3x3| { &m.m1_0 },
            |m: &mut Matrix3x3| { &mut m.m1_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_1",
            |m: &Matrix3x3| { &m.m1_1 },
            |m: &mut Matrix3x3| { &mut m.m1_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_2",
            |m: &Matrix3x3| { &m.m1_2 },
            |m: &mut Matrix3x3| { &mut m.m1_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_0",
            |m: &Matrix3x3| { &m.m2_0 },
            |m: &mut Matrix3x3| { &mut m.m2_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_1",
            |m: &Matrix3x3| { &m.m2_1 },
            |m: &mut Matrix3x3| { &mut m.m2_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_2",
            |m: &Matrix3x3| { &m.m2_2 },
            |m: &mut Matrix3x3| { &mut m.m2_2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Matrix3x3>(
            "Matrix3x3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Matrix3x3 {
    const NAME: &'static str = "Matrix3x3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_0)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_1)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_2)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_0)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_1)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_2)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_0)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_1)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_2)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.m0_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m0_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m0_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.m0_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.m0_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.m0_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.m1_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.m1_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.m1_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.m2_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.m2_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.m2_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Matrix3x3 {
        Matrix3x3::new()
    }

    fn clear(&mut self) {
        self.m0_0.clear();
        self.m0_1.clear();
        self.m0_2.clear();
        self.m1_0.clear();
        self.m1_1.clear();
        self.m1_2.clear();
        self.m2_0.clear();
        self.m2_1.clear();
        self.m2_2.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Matrix3x3 {
        static instance: Matrix3x3 = Matrix3x3 {
            m0_0: ::protobuf::MessageField::none(),
            m0_1: ::protobuf::MessageField::none(),
            m0_2: ::protobuf::MessageField::none(),
            m1_0: ::protobuf::MessageField::none(),
            m1_1: ::protobuf::MessageField::none(),
            m1_2: ::protobuf::MessageField::none(),
            m2_0: ::protobuf::MessageField::none(),
            m2_1: ::protobuf::MessageField::none(),
            m2_2: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Matrix3x3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Matrix3x3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Matrix3x3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Matrix3x3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Matrix4x4)
pub struct Matrix4x4 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m0_0)
    pub m0_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m0_1)
    pub m0_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m0_2)
    pub m0_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m0_3)
    pub m0_3: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m1_0)
    pub m1_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m1_1)
    pub m1_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m1_2)
    pub m1_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m1_3)
    pub m1_3: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m2_0)
    pub m2_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m2_1)
    pub m2_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m2_2)
    pub m2_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m2_3)
    pub m2_3: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m3_0)
    pub m3_0: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m3_1)
    pub m3_1: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m3_2)
    pub m3_2: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.Matrix4x4.m3_3)
    pub m3_3: ::protobuf::MessageField<Number>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Matrix4x4.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Matrix4x4 {
    fn default() -> &'a Matrix4x4 {
        <Matrix4x4 as ::protobuf::Message>::default_instance()
    }
}

impl Matrix4x4 {
    pub fn new() -> Matrix4x4 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_0",
            |m: &Matrix4x4| { &m.m0_0 },
            |m: &mut Matrix4x4| { &mut m.m0_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_1",
            |m: &Matrix4x4| { &m.m0_1 },
            |m: &mut Matrix4x4| { &mut m.m0_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_2",
            |m: &Matrix4x4| { &m.m0_2 },
            |m: &mut Matrix4x4| { &mut m.m0_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m0_3",
            |m: &Matrix4x4| { &m.m0_3 },
            |m: &mut Matrix4x4| { &mut m.m0_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_0",
            |m: &Matrix4x4| { &m.m1_0 },
            |m: &mut Matrix4x4| { &mut m.m1_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_1",
            |m: &Matrix4x4| { &m.m1_1 },
            |m: &mut Matrix4x4| { &mut m.m1_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_2",
            |m: &Matrix4x4| { &m.m1_2 },
            |m: &mut Matrix4x4| { &mut m.m1_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m1_3",
            |m: &Matrix4x4| { &m.m1_3 },
            |m: &mut Matrix4x4| { &mut m.m1_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_0",
            |m: &Matrix4x4| { &m.m2_0 },
            |m: &mut Matrix4x4| { &mut m.m2_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_1",
            |m: &Matrix4x4| { &m.m2_1 },
            |m: &mut Matrix4x4| { &mut m.m2_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_2",
            |m: &Matrix4x4| { &m.m2_2 },
            |m: &mut Matrix4x4| { &mut m.m2_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m2_3",
            |m: &Matrix4x4| { &m.m2_3 },
            |m: &mut Matrix4x4| { &mut m.m2_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m3_0",
            |m: &Matrix4x4| { &m.m3_0 },
            |m: &mut Matrix4x4| { &mut m.m3_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m3_1",
            |m: &Matrix4x4| { &m.m3_1 },
            |m: &mut Matrix4x4| { &mut m.m3_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m3_2",
            |m: &Matrix4x4| { &m.m3_2 },
            |m: &mut Matrix4x4| { &mut m.m3_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "m3_3",
            |m: &Matrix4x4| { &m.m3_3 },
            |m: &mut Matrix4x4| { &mut m.m3_3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Matrix4x4>(
            "Matrix4x4",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Matrix4x4 {
    const NAME: &'static str = "Matrix4x4";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_0)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_1)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_2)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m0_3)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_0)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_1)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_2)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m1_3)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_0)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_1)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_2)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m2_3)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m3_0)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m3_1)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m3_2)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.m3_3)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.m0_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m0_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m0_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m0_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m1_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m2_3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m3_0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m3_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m3_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.m3_3.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.m0_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.m0_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.m0_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.m0_3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.m1_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.m1_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.m1_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.m1_3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.m2_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.m2_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.m2_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.m2_3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.m3_0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.m3_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.m3_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.m3_3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Matrix4x4 {
        Matrix4x4::new()
    }

    fn clear(&mut self) {
        self.m0_0.clear();
        self.m0_1.clear();
        self.m0_2.clear();
        self.m0_3.clear();
        self.m1_0.clear();
        self.m1_1.clear();
        self.m1_2.clear();
        self.m1_3.clear();
        self.m2_0.clear();
        self.m2_1.clear();
        self.m2_2.clear();
        self.m2_3.clear();
        self.m3_0.clear();
        self.m3_1.clear();
        self.m3_2.clear();
        self.m3_3.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Matrix4x4 {
        static instance: Matrix4x4 = Matrix4x4 {
            m0_0: ::protobuf::MessageField::none(),
            m0_1: ::protobuf::MessageField::none(),
            m0_2: ::protobuf::MessageField::none(),
            m0_3: ::protobuf::MessageField::none(),
            m1_0: ::protobuf::MessageField::none(),
            m1_1: ::protobuf::MessageField::none(),
            m1_2: ::protobuf::MessageField::none(),
            m1_3: ::protobuf::MessageField::none(),
            m2_0: ::protobuf::MessageField::none(),
            m2_1: ::protobuf::MessageField::none(),
            m2_2: ::protobuf::MessageField::none(),
            m2_3: ::protobuf::MessageField::none(),
            m3_0: ::protobuf::MessageField::none(),
            m3_1: ::protobuf::MessageField::none(),
            m3_2: ::protobuf::MessageField::none(),
            m3_3: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Matrix4x4 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Matrix4x4").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Matrix4x4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Matrix4x4 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Transform)
pub struct Transform {
    // message oneof groups
    pub data: ::std::option::Option<transform::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Transform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transform {
    fn default() -> &'a Transform {
        <Transform as ::protobuf::Message>::default_instance()
    }
}

impl Transform {
    pub fn new() -> Transform {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.Transform2 transform2 = 1;

    pub fn transform2(&self) -> &Transform2 {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2(ref v)) => v,
            _ => <Transform2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transform2(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_transform2(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transform2(&mut self, v: Transform2) {
        self.data = ::std::option::Option::Some(transform::Data::Transform2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transform2(&mut self) -> &mut Transform2 {
        if let ::std::option::Option::Some(transform::Data::Transform2(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform::Data::Transform2(Transform2::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transform2(&mut self) -> Transform2 {
        if self.has_transform2() {
            match self.data.take() {
                ::std::option::Option::Some(transform::Data::Transform2(v)) => v,
                _ => panic!(),
            }
        } else {
            Transform2::new()
        }
    }

    // .observation_tools.proto.Transform3 transform3 = 2;

    pub fn transform3(&self) -> &Transform3 {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform3(ref v)) => v,
            _ => <Transform3 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transform3(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_transform3(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform3(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transform3(&mut self, v: Transform3) {
        self.data = ::std::option::Option::Some(transform::Data::Transform3(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transform3(&mut self) -> &mut Transform3 {
        if let ::std::option::Option::Some(transform::Data::Transform3(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform::Data::Transform3(Transform3::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform3(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transform3(&mut self) -> Transform3 {
        if self.has_transform3() {
            match self.data.take() {
                ::std::option::Option::Some(transform::Data::Transform3(v)) => v,
                _ => panic!(),
            }
        } else {
            Transform3::new()
        }
    }

    // .observation_tools.proto.Transform3 transform2_to_3 = 3;

    pub fn transform2_to_3(&self) -> &Transform3 {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2To3(ref v)) => v,
            _ => <Transform3 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transform2_to_3(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_transform2_to_3(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2To3(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transform2_to_3(&mut self, v: Transform3) {
        self.data = ::std::option::Option::Some(transform::Data::Transform2To3(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transform2_to_3(&mut self) -> &mut Transform3 {
        if let ::std::option::Option::Some(transform::Data::Transform2To3(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform::Data::Transform2To3(Transform3::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform::Data::Transform2To3(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transform2_to_3(&mut self) -> Transform3 {
        if self.has_transform2_to_3() {
            match self.data.take() {
                ::std::option::Option::Some(transform::Data::Transform2To3(v)) => v,
                _ => panic!(),
            }
        } else {
            Transform3::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Transform2>(
            "transform2",
            Transform::has_transform2,
            Transform::transform2,
            Transform::mut_transform2,
            Transform::set_transform2,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Transform3>(
            "transform3",
            Transform::has_transform3,
            Transform::transform3,
            Transform::mut_transform3,
            Transform::set_transform3,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Transform3>(
            "transform2_to_3",
            Transform::has_transform2_to_3,
            Transform::transform2_to_3,
            Transform::mut_transform2_to_3,
            Transform::set_transform2_to_3,
        ));
        oneofs.push(transform::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transform>(
            "Transform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transform {
    const NAME: &'static str = "Transform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(transform::Data::Transform2(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(transform::Data::Transform3(is.read_message()?));
                },
                26 => {
                    self.data = ::std::option::Option::Some(transform::Data::Transform2To3(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform::Data::Transform2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transform::Data::Transform3(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transform::Data::Transform2To3(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform::Data::Transform2(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transform::Data::Transform3(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &transform::Data::Transform2To3(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transform {
        Transform::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transform {
        static instance: Transform = Transform {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transform`
pub mod transform {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.Transform.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform.transform2)
        Transform2(super::Transform2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform.transform3)
        Transform3(super::Transform3),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform.transform2_to_3)
        Transform2To3(super::Transform3),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Transform as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Transform2)
pub struct Transform2 {
    // message oneof groups
    pub data: ::std::option::Option<transform2::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Transform2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transform2 {
    fn default() -> &'a Transform2 {
        <Transform2 as ::protobuf::Message>::default_instance()
    }
}

impl Transform2 {
    pub fn new() -> Transform2 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.TRS2 trs = 1;

    pub fn trs(&self) -> &TRS2 {
        match self.data {
            ::std::option::Option::Some(transform2::Data::Trs(ref v)) => v,
            _ => <TRS2 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_trs(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_trs(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform2::Data::Trs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trs(&mut self, v: TRS2) {
        self.data = ::std::option::Option::Some(transform2::Data::Trs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trs(&mut self) -> &mut TRS2 {
        if let ::std::option::Option::Some(transform2::Data::Trs(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform2::Data::Trs(TRS2::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform2::Data::Trs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trs(&mut self) -> TRS2 {
        if self.has_trs() {
            match self.data.take() {
                ::std::option::Option::Some(transform2::Data::Trs(v)) => v,
                _ => panic!(),
            }
        } else {
            TRS2::new()
        }
    }

    // bool identity = 2;

    pub fn identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform2::Data::Identity(v)) => v,
            _ => false,
        }
    }

    pub fn clear_identity(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform2::Data::Identity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(transform2::Data::Identity(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TRS2>(
            "trs",
            Transform2::has_trs,
            Transform2::trs,
            Transform2::mut_trs,
            Transform2::set_trs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "identity",
            Transform2::has_identity,
            Transform2::identity,
            Transform2::set_identity,
        ));
        oneofs.push(transform2::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transform2>(
            "Transform2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transform2 {
    const NAME: &'static str = "Transform2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(transform2::Data::Trs(is.read_message()?));
                },
                16 => {
                    self.data = ::std::option::Option::Some(transform2::Data::Identity(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform2::Data::Trs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transform2::Data::Identity(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform2::Data::Trs(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transform2::Data::Identity(v) => {
                    os.write_bool(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transform2 {
        Transform2::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transform2 {
        static instance: Transform2 = Transform2 {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transform2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transform2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transform2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transform2`
pub mod transform2 {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.Transform2.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform2.trs)
        Trs(super::TRS2),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform2.identity)
        Identity(bool),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Transform2 as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.Transform3)
pub struct Transform3 {
    // message oneof groups
    pub data: ::std::option::Option<transform3::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.Transform3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transform3 {
    fn default() -> &'a Transform3 {
        <Transform3 as ::protobuf::Message>::default_instance()
    }
}

impl Transform3 {
    pub fn new() -> Transform3 {
        ::std::default::Default::default()
    }

    // .observation_tools.proto.TRS3 trs = 1;

    pub fn trs(&self) -> &TRS3 {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Trs(ref v)) => v,
            _ => <TRS3 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_trs(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_trs(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Trs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trs(&mut self, v: TRS3) {
        self.data = ::std::option::Option::Some(transform3::Data::Trs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trs(&mut self) -> &mut TRS3 {
        if let ::std::option::Option::Some(transform3::Data::Trs(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform3::Data::Trs(TRS3::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform3::Data::Trs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trs(&mut self) -> TRS3 {
        if self.has_trs() {
            match self.data.take() {
                ::std::option::Option::Some(transform3::Data::Trs(v)) => v,
                _ => panic!(),
            }
        } else {
            TRS3::new()
        }
    }

    // .observation_tools.proto.Matrix4x4 matrix = 2;

    pub fn matrix(&self) -> &Matrix4x4 {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Matrix(ref v)) => v,
            _ => <Matrix4x4 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_matrix(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_matrix(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Matrix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matrix(&mut self, v: Matrix4x4) {
        self.data = ::std::option::Option::Some(transform3::Data::Matrix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matrix(&mut self) -> &mut Matrix4x4 {
        if let ::std::option::Option::Some(transform3::Data::Matrix(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(transform3::Data::Matrix(Matrix4x4::new()));
        }
        match self.data {
            ::std::option::Option::Some(transform3::Data::Matrix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matrix(&mut self) -> Matrix4x4 {
        if self.has_matrix() {
            match self.data.take() {
                ::std::option::Option::Some(transform3::Data::Matrix(v)) => v,
                _ => panic!(),
            }
        } else {
            Matrix4x4::new()
        }
    }

    // bool identity = 3;

    pub fn identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Identity(v)) => v,
            _ => false,
        }
    }

    pub fn clear_identity(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(transform3::Data::Identity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(transform3::Data::Identity(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TRS3>(
            "trs",
            Transform3::has_trs,
            Transform3::trs,
            Transform3::mut_trs,
            Transform3::set_trs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Matrix4x4>(
            "matrix",
            Transform3::has_matrix,
            Transform3::matrix,
            Transform3::mut_matrix,
            Transform3::set_matrix,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "identity",
            Transform3::has_identity,
            Transform3::identity,
            Transform3::set_identity,
        ));
        oneofs.push(transform3::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transform3>(
            "Transform3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transform3 {
    const NAME: &'static str = "Transform3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(transform3::Data::Trs(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(transform3::Data::Matrix(is.read_message()?));
                },
                24 => {
                    self.data = ::std::option::Option::Some(transform3::Data::Identity(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform3::Data::Trs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transform3::Data::Matrix(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transform3::Data::Identity(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &transform3::Data::Trs(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transform3::Data::Matrix(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &transform3::Data::Identity(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transform3 {
        Transform3::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transform3 {
        static instance: Transform3 = Transform3 {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transform3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transform3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transform3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transform3`
pub mod transform3 {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:observation_tools.proto.Transform3.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform3.trs)
        Trs(super::TRS3),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform3.matrix)
        Matrix(super::Matrix4x4),
        // @@protoc_insertion_point(oneof_field:observation_tools.proto.Transform3.identity)
        Identity(bool),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Transform3 as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.TRS2)
pub struct TRS2 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.TRS2.translation)
    pub translation: ::protobuf::MessageField<Point2>,
    // @@protoc_insertion_point(field:observation_tools.proto.TRS2.rotation)
    pub rotation: ::protobuf::MessageField<Number>,
    // @@protoc_insertion_point(field:observation_tools.proto.TRS2.scale)
    pub scale: ::protobuf::MessageField<Vector2>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.TRS2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TRS2 {
    fn default() -> &'a TRS2 {
        <TRS2 as ::protobuf::Message>::default_instance()
    }
}

impl TRS2 {
    pub fn new() -> TRS2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point2>(
            "translation",
            |m: &TRS2| { &m.translation },
            |m: &mut TRS2| { &mut m.translation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Number>(
            "rotation",
            |m: &TRS2| { &m.rotation },
            |m: &mut TRS2| { &mut m.rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Vector2>(
            "scale",
            |m: &TRS2| { &m.scale },
            |m: &mut TRS2| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TRS2>(
            "TRS2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TRS2 {
    const NAME: &'static str = "TRS2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translation)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.translation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.translation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.rotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.scale.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TRS2 {
        TRS2::new()
    }

    fn clear(&mut self) {
        self.translation.clear();
        self.rotation.clear();
        self.scale.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TRS2 {
        static instance: TRS2 = TRS2 {
            translation: ::protobuf::MessageField::none(),
            rotation: ::protobuf::MessageField::none(),
            scale: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TRS2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TRS2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TRS2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TRS2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:observation_tools.proto.TRS3)
pub struct TRS3 {
    // message fields
    // @@protoc_insertion_point(field:observation_tools.proto.TRS3.translation)
    pub translation: ::protobuf::MessageField<Point3>,
    // @@protoc_insertion_point(field:observation_tools.proto.TRS3.scale)
    pub scale: ::protobuf::MessageField<Vector3>,
    // special fields
    // @@protoc_insertion_point(special_field:observation_tools.proto.TRS3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TRS3 {
    fn default() -> &'a TRS3 {
        <TRS3 as ::protobuf::Message>::default_instance()
    }
}

impl TRS3 {
    pub fn new() -> TRS3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point3>(
            "translation",
            |m: &TRS3| { &m.translation },
            |m: &mut TRS3| { &mut m.translation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Vector3>(
            "scale",
            |m: &TRS3| { &m.scale },
            |m: &mut TRS3| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TRS3>(
            "TRS3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TRS3 {
    const NAME: &'static str = "TRS3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.translation)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.translation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.translation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TRS3 {
        TRS3::new()
    }

    fn clear(&mut self) {
        self.translation.clear();
        self.scale.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TRS3 {
        static instance: TRS3 = TRS3 {
            translation: ::protobuf::MessageField::none(),
            scale: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TRS3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TRS3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TRS3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TRS3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14src/proto/math.proto\x12\x17observation_tools.proto\"\x16\n\x06Num\
    ber\x12\x0c\n\x01d\x18\x01\x20\x01(\x01R\x01d\"f\n\x06Point2\x12-\n\x01x\
    \x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01x\x12-\n\
    \x01y\x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01y\"t\
    \n\x08Segment2\x125\n\x05start\x18\x01\x20\x01(\x0b2\x1f.observation_too\
    ls.proto.Point2R\x05start\x121\n\x03end\x18\x02\x20\x01(\x0b2\x1f.observ\
    ation_tools.proto.Point2R\x03end\"\x95\x01\n\x06Point3\x12-\n\x01x\x18\
    \x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01x\x12-\n\x01y\
    \x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01y\x12-\n\
    \x01z\x18\x03\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01z\"g\
    \n\x07Vector2\x12-\n\x01x\x18\x01\x20\x01(\x0b2\x1f.observation_tools.pr\
    oto.NumberR\x01x\x12-\n\x01y\x18\x02\x20\x01(\x0b2\x1f.observation_tools\
    .proto.NumberR\x01y\"\x96\x01\n\x07Vector3\x12-\n\x01x\x18\x01\x20\x01(\
    \x0b2\x1f.observation_tools.proto.NumberR\x01x\x12-\n\x01y\x18\x02\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x01y\x12-\n\x01z\x18\x03\
    \x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x01z\"G\n\x0cPolygonE\
    dge2\x127\n\x06vertex\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.\
    Point2R\x06vertex\"G\n\x08Polygon2\x12;\n\x05edges\x18\x01\x20\x03(\x0b2\
    %.observation_tools.proto.PolygonEdge2R\x05edges\"=\n\x05Rect2\x124\n\
    \x04size\x18\x01\x20\x01(\x0b2\x20.observation_tools.proto.Vector2R\x04s\
    ize\"G\n\x0cPolygonEdge3\x127\n\x06vertex\x18\x01\x20\x01(\x0b2\x1f.obse\
    rvation_tools.proto.Point3R\x06vertex\"G\n\x08Polygon3\x12;\n\x05edges\
    \x18\x01\x20\x03(\x0b2%.observation_tools.proto.PolygonEdge3R\x05edges\"\
    \xc5\x02\n\x05Graph\x12?\n\x05nodes\x18\x01\x20\x03(\x0b2).observation_t\
    ools.proto.Graph.NodesEntryR\x05nodes\x12?\n\x05edges\x18\x02\x20\x03(\
    \x0b2).observation_tools.proto.Graph.EdgesEntryR\x05edges\x1a\\\n\nNodes\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x128\n\x05value\x18\
    \x02\x20\x01(\x0b2\".observation_tools.proto.GraphNodeR\x05value:\x028\
    \x01\x1a\\\n\nEdgesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    8\n\x05value\x18\x02\x20\x01(\x0b2\".observation_tools.proto.GraphEdgeR\
    \x05value:\x028\x01\"H\n\tGraphNode\x12;\n\x08position\x18\x01\x20\x01(\
    \x0b2\x1f.observation_tools.proto.Point3R\x08position\"O\n\tGraphEdge\
    \x12\"\n\rstart_node_id\x18\x01\x20\x01(\tR\x0bstartNodeId\x12\x1e\n\x0b\
    end_node_id\x18\x02\x20\x01(\tR\tendNodeId\"\xdf\x03\n\tMatrix3x3\x122\n\
    \x04m0_0\x18\x01\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m0\
    0\x122\n\x04m0_1\x18\x02\x20\x01(\x0b2\x1f.observation_tools.proto.Numbe\
    rR\x03m01\x122\n\x04m0_2\x18\x03\x20\x01(\x0b2\x1f.observation_tools.pro\
    to.NumberR\x03m02\x122\n\x04m1_0\x18\x04\x20\x01(\x0b2\x1f.observation_t\
    ools.proto.NumberR\x03m10\x122\n\x04m1_1\x18\x05\x20\x01(\x0b2\x1f.obser\
    vation_tools.proto.NumberR\x03m11\x122\n\x04m1_2\x18\x06\x20\x01(\x0b2\
    \x1f.observation_tools.proto.NumberR\x03m12\x122\n\x04m2_0\x18\x07\x20\
    \x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m20\x122\n\x04m2_1\x18\
    \x08\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m21\x122\n\x04\
    m2_2\x18\t\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m22\"\
    \xcb\x06\n\tMatrix4x4\x122\n\x04m0_0\x18\x01\x20\x01(\x0b2\x1f.observati\
    on_tools.proto.NumberR\x03m00\x122\n\x04m0_1\x18\x02\x20\x01(\x0b2\x1f.o\
    bservation_tools.proto.NumberR\x03m01\x122\n\x04m0_2\x18\x03\x20\x01(\
    \x0b2\x1f.observation_tools.proto.NumberR\x03m02\x122\n\x04m0_3\x18\x04\
    \x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m03\x122\n\x04m1_0\
    \x18\x05\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m10\x122\n\
    \x04m1_1\x18\x06\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m1\
    1\x122\n\x04m1_2\x18\x07\x20\x01(\x0b2\x1f.observation_tools.proto.Numbe\
    rR\x03m12\x122\n\x04m1_3\x18\x08\x20\x01(\x0b2\x1f.observation_tools.pro\
    to.NumberR\x03m13\x122\n\x04m2_0\x18\t\x20\x01(\x0b2\x1f.observation_too\
    ls.proto.NumberR\x03m20\x122\n\x04m2_1\x18\n\x20\x01(\x0b2\x1f.observati\
    on_tools.proto.NumberR\x03m21\x122\n\x04m2_2\x18\x0b\x20\x01(\x0b2\x1f.o\
    bservation_tools.proto.NumberR\x03m22\x122\n\x04m2_3\x18\x0c\x20\x01(\
    \x0b2\x1f.observation_tools.proto.NumberR\x03m23\x122\n\x04m3_0\x18\r\
    \x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m30\x122\n\x04m3_1\
    \x18\x0e\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m31\x122\n\
    \x04m3_2\x18\x0f\x20\x01(\x0b2\x1f.observation_tools.proto.NumberR\x03m3\
    2\x122\n\x04m3_3\x18\x10\x20\x01(\x0b2\x1f.observation_tools.proto.Numbe\
    rR\x03m33\"\xf0\x01\n\tTransform\x12E\n\ntransform2\x18\x01\x20\x01(\x0b\
    2#.observation_tools.proto.Transform2H\0R\ntransform2\x12E\n\ntransform3\
    \x18\x02\x20\x01(\x0b2#.observation_tools.proto.Transform3H\0R\ntransfor\
    m3\x12M\n\x0ftransform2_to_3\x18\x03\x20\x01(\x0b2#.observation_tools.pr\
    oto.Transform3H\0R\rtransform2To3B\x06\n\x04data\"e\n\nTransform2\x121\n\
    \x03trs\x18\x01\x20\x01(\x0b2\x1d.observation_tools.proto.TRS2H\0R\x03tr\
    s\x12\x1c\n\x08identity\x18\x02\x20\x01(\x08H\0R\x08identityB\x06\n\x04d\
    ata\"\xa3\x01\n\nTransform3\x121\n\x03trs\x18\x01\x20\x01(\x0b2\x1d.obse\
    rvation_tools.proto.TRS3H\0R\x03trs\x12<\n\x06matrix\x18\x02\x20\x01(\
    \x0b2\".observation_tools.proto.Matrix4x4H\0R\x06matrix\x12\x1c\n\x08ide\
    ntity\x18\x03\x20\x01(\x08H\0R\x08identityB\x06\n\x04data\"\xbe\x01\n\
    \x04TRS2\x12A\n\x0btranslation\x18\x01\x20\x01(\x0b2\x1f.observation_too\
    ls.proto.Point2R\x0btranslation\x12;\n\x08rotation\x18\x02\x20\x01(\x0b2\
    \x1f.observation_tools.proto.NumberR\x08rotation\x126\n\x05scale\x18\x03\
    \x20\x01(\x0b2\x20.observation_tools.proto.Vector2R\x05scale\"\x81\x01\n\
    \x04TRS3\x12A\n\x0btranslation\x18\x01\x20\x01(\x0b2\x1f.observation_too\
    ls.proto.Point3R\x0btranslation\x126\n\x05scale\x18\x03\x20\x01(\x0b2\
    \x20.observation_tools.proto.Vector3R\x05scaleB\x1b\n\x17tools.observati\
    on.protoP\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(Number::generated_message_descriptor_data());
            messages.push(Point2::generated_message_descriptor_data());
            messages.push(Segment2::generated_message_descriptor_data());
            messages.push(Point3::generated_message_descriptor_data());
            messages.push(Vector2::generated_message_descriptor_data());
            messages.push(Vector3::generated_message_descriptor_data());
            messages.push(PolygonEdge2::generated_message_descriptor_data());
            messages.push(Polygon2::generated_message_descriptor_data());
            messages.push(Rect2::generated_message_descriptor_data());
            messages.push(PolygonEdge3::generated_message_descriptor_data());
            messages.push(Polygon3::generated_message_descriptor_data());
            messages.push(Graph::generated_message_descriptor_data());
            messages.push(GraphNode::generated_message_descriptor_data());
            messages.push(GraphEdge::generated_message_descriptor_data());
            messages.push(Matrix3x3::generated_message_descriptor_data());
            messages.push(Matrix4x4::generated_message_descriptor_data());
            messages.push(Transform::generated_message_descriptor_data());
            messages.push(Transform2::generated_message_descriptor_data());
            messages.push(Transform3::generated_message_descriptor_data());
            messages.push(TRS2::generated_message_descriptor_data());
            messages.push(TRS3::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
